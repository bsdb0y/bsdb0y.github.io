<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Deep dive into OpenBSD malloc(3) internals</title>
</head>
<body>
    <header>
    <a href="/" style="color:#444444;text-decoration:none;"><h2>#BSDBOY</h2></a>
    </header>
<font size="+1">
<a href="/pages/books.html">Books</a> |
<a href="https://marc.info/?a=149745405500002&r=1&w=2" target="_blank">Mailing List (marc.info)</a> |
<a href="https://twitter.com/_neerajpal" target="_blank">Twitter</a> |
<a href="https://github.com/neerajpal09" target="_blank">Github</a> |
<a href="https://stackexchange.com/users/6592094/neeraj-pal?tab=accounts" target="_blank">StackExchange</a> |
<a href="https://www.linkedin.com/in/neerajpal09/" target="_blank">LinkedIn</a> |
<a href="/pages/about.html">About Me</a>
<h2></h2>
</font>

    <h1 class="post-title">
	    Tale of OpenBSD secure memory allocator internals -  malloc(3) <font size=5> [Part - 1] </font> 
    </h1>

<figure>
  <img src="/images/blogpost_images/5_/debug_with_gdb.png" alt="debug_with_gdb" style="width:100%">
  <figcaption>Fig.1 malloc debugging with gdb</figcaption>
</figure>

<p>Hi there,</p>

<p>It's been a very long time I haven't written anything after my last OpenBSD blogs about pledge and kernel internals.
<p>So, again I started reading OpenBSD source codes with debugger after reducing my sleep timings and managing to get some time after professional life. This time I have picked one of my favourite item from my wishlist to learn and share, that is, OpenBSD <a href="/https://man.openbsd.org/malloc.3">malloc(3)</a>, secure allocator

<p>I will try to keep it as <b><i>n</i></b> part series due to lengthy content and this series will be mostly focussed on user-space code of <a href="/https://man.openbsd.org/malloc.3">malloc(3)</a>

<p>First of all, I would like to thanks to <b><i><a href="https://twitter.com/ottom6k">Otto Moerbeek</a></i></b>, <b><i><a href="https://twitter.com/canadianbryan">Bryan Steel</a></i></b> and <b><i>Fabien Romano</i></b> for helping me to understand the <a href="https://man.openbsd.org/malloc.3">malloc(3)</a> internals and cleared all my queries.

<p>So, we should start now... :) 

<p>I have used the following sample code to start my journey with the OpenBSD 6.6-stable <a href="https://man.openbsd.org/malloc.3">malloc(3)</a>
<pre>
<code>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int
main(int argc, char **argv) {
	char *buff1 = NULL;
	buff1 = (char *)malloc(8);
	strcpy(buff1, argv[1]);
	free(buff1);
	return 0;
}
</code>
</pre>
<p>Compiled the libc with debug symbols and switched off the optimization by compiling it with clang option "-O0 -g".

<h5><p>Followed the below steps to compile the libc with debug symbols</h5>
<pre>
<code>
<p>1. cd $openbsd_src_directory
<p>2. cd lib/libc
<p>3. CFLAGS="-g -O0" CXXFLAGS="-g -O0" make obj
<p>4. CFLAGS="-g -O0" CXXFLAGS="-g -O0" make -j4 
</ul>
</pre>
</code>
<p>I haven't installed it and used gdb-style debugging approach for code reading instead of debugging with printf style debugging.

<p>For printf style debugging, one can use <a href="https://man.openbsd.org/dprintf.3">dprintf(3)</a> or <a href="https://man.openbsd.org/write.2">write(2)</a> calls to print anything but keep in mind that after installation of libc with printf statements it will dump lots of information for each and every binary, so installation step is no use for <a href="https://man.openbsd.org/malloc.3">malloc(3)</a>debugging.

<p>I would say one can either compile and use LD_PRELOAD to load the compiled libc and use debugger or one can compile with printf statements then use the same LD_PRELOAD for that specific sample code.

<p> So, just after the <a href="https://man.openbsd.org/malloc.3">malloc(3)</a> from the sample code, it directly jumps to function malloc(size_t size) from file <span><i>/usr/src/lib/libc/stdlib/malloc.c:1278</i></span>
<pre>
<code>
1277 void *
1278 malloc(size_t size)
1279 {
1280         void *r;
1281         struct dir_info *d;
1282         int saved_errno = errno;
1283
1284         PROLOGUE(getpool(), "malloc")
1285         r = omalloc(d, size, 0, CALLER);
1286         EPILOGUE()
1287         return r;
1288 }
</pre>
</code>
<font size="2">
	<p align="center">code snippet #00
</font>
<p> As explained by the developer <b><i><a href="https://twitter.com/ottom6k">Otto@</a></i></b> in the <b><i><a href="https://twitter.com/ottom6k/status/1236170000312012800">tweet on twitter</a></i></b> that <b><i>struct dir_info</i></b> contains all the meta information malloc needs to keep track of what page regions have been allocated, which pages regions are in the free-cache and for pages of chunks which chunks are free and which are allocated.

<p> So, as per the code given above, one can see after some basic initialization-declaration, there is some macro PROLOGUE and EPILOGUE. It means the same like how it sounds, usually these two means,

<h5><p>prologue:</p></h5>
<p><a href="https:/en.wikipedia.org/wiki/Function_prologue#Prologue">Function prologue</a>. In assembly language programming, the function prologue is a few lines of code at the beginning of a function, which prepare the stack and registers for use within the function. Here, instead of preparing the stack and registers, it initializes some other necessary malloc requirements that we will see later.

<h5><p>epilogue:</p></h5>
<p><a href="https://en.wikipedia.org/wiki/Function_prologue#Epilogue">Function epilogue</a> reverses the actions of the function prologue and returns control to the calling function.

<p>PROLGOUE macro given below:
<pre>
<code>
1256 #define PROLOGUE(p, fn)                 \
1257         d = (p);                        \
1258         if (d == NULL) {                \
1259                 _malloc_init(0);        \
1260                 d = (p);                \
1261         }                               \
1262         _MALLOC_LOCK(d->mutex);         \
1263         d->func = fn;                   \
1264         if (d->active++) {              \
1265                 malloc_recurse(d);      \
1266                 return NULL;            \
1267         }                               \
</pre>
</code>
<font size="2">
	<p align="center">code snippet #01
</font>
<p>As from the [code snippet #00], we can see that  <b><i>p</i></b> is <b><i>getpool()</i></b> and <b><i>fn</i></b> is callee function, that is, <b><i>"malloc"</i></b>
<p> As from the [code snippet 01], we can see that it first calls <b><i>getpool()</i></b> function and the code for <b><i>getpool()</i></b> given below
<pre>
<code>
270 static inline struct dir_info *
271 getpool(void)
272 {
273         if (!mopts.malloc_mt)
274                 return mopts.malloc_pool[1];
275         else    /* first one reserved for special pool */
276                 return mopts.malloc_pool[1 + TIB_GET()->tib_tid %
277                     (mopts.malloc_mutexes - 1)];
278 }
</pre>
</code>
<font size="2">
	<p align="center">code snippet #02
</font>
<p> In the [code snippet #02] we can see that first it checks whether it has multi-threads or single-threads. And, in our case it is single threaded binary, so after <b><i>if</i></b> it returns <b><i>mopts.malloc_pool[1]</i></b> which is <b><i>NULL</i></b>.
<p>Now, after that from the [code snippet #01] it checks whether <b><i>d</i></b> is <b><i>NULL</i></b> or not. In our case it is <b><i>NULL</i></b> as at first it will always be <b><i>NULL</i></b> after that it calls <b><i>_malloc_init(0)</i></b> but when <b><i>d</i></b> is <b><i>not NULL</i></b> then it assigns <b><i>fn</i></b> to <b><i>d->func</i></b> then check and increment the <b><i>d->active</i></b> then calls <b><i>malloc_recurse(d)</i></b> and returns <b><i>NULL</i></b> but for our situation it is not the flow.
<p>Code for <b><i>_malloc_init(0)</i></b> given below
<pre>
<code>
1207 void
1208 _malloc_init(int from_rthreads)
1209 {
1210         u_int i, nmutexes;
1211         struct dir_info *d;
1212 
1213         _MALLOC_LOCK(1);
1214         if (!from_rthreads && mopts.malloc_pool[1]) {
1215                 _MALLOC_UNLOCK(1);
1216                 return;
1217         }
1218         if (!mopts.malloc_canary)
1219                 omalloc_init();
1220 
1221         nmutexes = from_rthreads ? mopts.malloc_mutexes : 2;
1222         if (((uintptr_t)&malloc_readonly & MALLOC_PAGEMASK) == 0)
1223                 mprotect(&malloc_readonly, sizeof(malloc_readonly),
1224                     PROT_READ | PROT_WRITE);
1225         for (i = 0; i < nmutexes; i++) {
1226                 if (mopts.malloc_pool[i])
1227                         continue;
1228                 if (i == 0) {
1229                         omalloc_poolinit(&d, MAP_CONCEAL);
1230                         d->malloc_junk = 2;
1231                         d->malloc_cache = 0;
1232                 } else {
1233                         omalloc_poolinit(&d, 0);
1234                         d->malloc_junk = mopts.def_malloc_junk;
1235                         d->malloc_cache = mopts.def_malloc_cache;
1236                 }
1237                 d->mutex = i;
1238                 mopts.malloc_pool[i] = d;
1239         }
1240 
1241         if (from_rthreads)
1242                 mopts.malloc_mt = 1;
1243         else
1244                 mopts.internal_funcs = 1;
1245 
1246         /*
1247          * Options have been set and will never be reset.
1248          * Prevent further tampering with them.
1249          */
1250         if (((uintptr_t)&malloc_readonly & MALLOC_PAGEMASK) == 0)
1251                 mprotect(&malloc_readonly, sizeof(malloc_readonly), PROT_READ);
1252         _MALLOC_UNLOCK(1);
1253 }
</pre>
</code>
<font size="2">
	<p align="center">code snippet #03
</font>
<p> In the [code snippet #03], we can see that first it does some MALLOC_LOCKing and checks for the <b><i>from_rthreads</i></b> and also for <b><i>mopts.malloc_pool[1]</i></b> as an outcome it is not <b><i>true</i></b> due to <b><i>mopts.malloc_pool[1]</i></b> which is <b><i>NULL</i></b>
<p> Then, after that it checks for <b><i>mopts.malloc_canary</i></b> and it wil be always 0 first time due to structure initialized to zero (0) and then it calls function <b><i>omalloc_init()</i></b> and code for the same given below
<pre>
<code>
405	static void
406	omalloc_init(void)
407	{
408		char *p, *q, b[16];
409		int i, j, mib[2];
410		size_t sb;
411
412		/*
413		 * Default options
414		 */
415		mopts.malloc_mutexes = 8;
416		mopts.def_malloc_junk = 1;
417		mopts.def_malloc_cache = MALLOC_DEFAULT_CACHE;
418
419		for (i = 0; i < 3; i++) {
420			switch (i) {
421			case 0:
422				mib[0] = CTL_VM;
423				mib[1] = VM_MALLOC_CONF;
424				sb = sizeof(b);
425				j = sysctl(mib, 2, b, &sb, NULL, 0);
426				if (j != 0)
427					continue;
428				p = b;
429				break;
430			case 1:
431				if (issetugid() == 0)
432					p = getenv("MALLOC_OPTIONS");
433				else
434					continue;
435				break;
436			case 2:
437				p = malloc_options;
438				break;
439			default:
440				p = NULL;
441			}
442
443			for (; p != NULL && *p != '\0'; p++) {
444				switch (*p) {
445				case 'S':
446					for (q = "CFGJ"; *q != '\0'; q++)
447						omalloc_parseopt(*q);
448					mopts.def_malloc_cache = 0;
449					break;
450				case 's':
451					for (q = "cfgj"; *q != '\0'; q++)
452						omalloc_parseopt(*q);
453					mopts.def_malloc_cache = MALLOC_DEFAULT_CACHE;
454					break;
455				default:
456					omalloc_parseopt(*p);
457					break;
458				}
459			}
460		}
461
462	#ifdef MALLOC_STATS
463		if (mopts.malloc_stats && (atexit(malloc_exit) == -1)) {
464			dprintf(STDERR_FILENO, "malloc() warning: atexit(2) failed."
465			    " Will not be able to dump stats on exit\n");
466		}
467	#endif /* MALLOC_STATS */
468
469		while ((mopts.malloc_canary = arc4random()) == 0)
470			;
471	}
</pre>
</code>
<font size="2">
	<p align="center">code snippet #04
</font>
<p>OpenBSD malloc(3) has lots of feature and they are configurable using <i>systcl(8)</i>, environment variable <i>MALLOC_OPTIONS</i> and compile-time option <i>malloc_options</i> 
<p>So, let's suppose one want to use the canary option then one has to set the option using systcl(8), like I have used it from the command: <b><i>systcl vm.malloc_conf=C</i></b>
<p><b><i>omalloc_init()</i></b> does the following things:
<ul>
	<li><p>initializes some variables of <b><i>malloc_readonly</i></b> structure to default values like <b><i>mopts.malloc_mutexes</i></b> is the default number of mutexes, <b><i>mopts.def_malloc_junk</i></b> is the default number of junk filling and <b><i>mopts.def_malloc_cache</i></b> is the default number of free page cache</li>
	<li><p>then, it checks one by one for all 3 ways that is mentioned above for setting a malloc option. In our case, I have used systcl(8) option, so for sysctl it goes to <i>case 0:</i> and get the value to <i>char b[16]</i> and then it assigns to pointer to character variable <i>p</i> then after looping for other two it goes for extracting the value that is there in <i>p</i></li>
	<li><p>first it checks for the malloc option <b><i>S</i></b> which enables all the security auditing features of OpenBSD <a href="https://man.openbsd.org/malloc.3">malloc(3)</a></li>
	<ul>
		<li>if it is there then it calls <b><i>omalloc_parseopt(*q);</i></b> function then after that it sets <b><i>mopts.def_malloc_cache</i></b> to <b><i>0</i></b> or to <b><i>MALLOC_DEFAULT_CACHE</i></b>, depends on whether it is <b><i>S</i></b> or <b><i>s</i></b></li>
		<li>if it is not there, then it simply calls the function <b><i>omalloc_parseopt(*p);</i></b></li>
	</ul>
</ul>
<p> function <b><i>omalloc_parseopt(char opt)</i></b> extracts the character and in our case it is <b><i>C</i></b> for malloc canary, so after parsing, it goes to <b><i>case 'C'</i></b> and sets <b><i>mopts.chunk_canaries</i></b> to <b><i>1</i></b>, it does the same for other characters and sets or enables/initializes their variables. Code for the same function given below: 
<pre>
<code>
322	static void
323	omalloc_parseopt(char opt)
324	{
325		switch (opt) {
326		case '+':
327			mopts.malloc_mutexes <<= 1;
328			if (mopts.malloc_mutexes > _MALLOC_MUTEXES)
329				mopts.malloc_mutexes = _MALLOC_MUTEXES;
330			break;
331		case '-':
332			mopts.malloc_mutexes >>= 1;
333			if (mopts.malloc_mutexes < 2)
334				mopts.malloc_mutexes = 2;
335			break;
336		case '>':
337			mopts.def_malloc_cache <<= 1;
338			if (mopts.def_malloc_cache > MALLOC_MAXCACHE)
339				mopts.def_malloc_cache = MALLOC_MAXCACHE;
340			break;
341		case '<':
342			mopts.def_malloc_cache >>= 1;
343			break;
344		case 'c':
345			mopts.chunk_canaries = 0;
346			break;
347		case 'C':
348			mopts.chunk_canaries = 1;
349			break;
350	#ifdef MALLOC_STATS
351		case 'd':
352			mopts.malloc_stats = 0;
353			break;
354		case 'D':
355			mopts.malloc_stats = 1;
356			break;
357	#endif /* MALLOC_STATS */
358		case 'f':
359			mopts.malloc_freecheck = 0;
360			mopts.malloc_freeunmap = 0;
361			break;
362		case 'F':
363			mopts.malloc_freecheck = 1;
364			mopts.malloc_freeunmap = 1;
365			break;
366		case 'g':
367			mopts.malloc_guard = 0;
368			break;
369		case 'G':
370			mopts.malloc_guard = MALLOC_PAGESIZE;
371			break;
372		case 'j':
373			if (mopts.def_malloc_junk > 0)
374				mopts.def_malloc_junk--;
375			break;
376		case 'J':
377			if (mopts.def_malloc_junk < 2)
378				mopts.def_malloc_junk++;
379			break;
380		case 'r':
381			mopts.malloc_realloc = 0;
382			break;
383		case 'R':
384			mopts.malloc_realloc = 1;
385			break;
386		case 'u':
387			mopts.malloc_freeunmap = 0;
388			break;
389		case 'U':
390			mopts.malloc_freeunmap = 1;
391			break;
392		case 'x':
393			mopts.malloc_xmalloc = 0;
394			break;
395		case 'X':
396			mopts.malloc_xmalloc = 1;
397			break;
398		default:
399			dprintf(STDERR_FILENO, "malloc() warning: "
400	                    "unknown char in MALLOC_OPTIONS\n");
401			break;
402		}
403	}
</pre>
</code>
<font size="2">
	<p align="center">code snippet #05
</font>
<p> There are some <b><i>ifdef MALLOC_STATS</i></b> in the entire source, which means it dumps extra malloc stats information whenever requires. So, as from the [code snippet #04], after completing <b><i>omalloc_parseopt(char opt)</i></b>, there is some MALLOC_STATS condition then after them, a random cookie assigns to <b><i>mopts.malloc_canary</i></b> using <b><i>arc4random()</i></b> 
<p>After the completion of <b><i>omalloc_init()</i></b>, coming again to [code snippet #03], there a variable named <b><i>nmutexes</i></b> which sets bydefault to <b><i>2</i></b> for single-threaded programs, we have already seen the initalization of <b><i>mopts.malloc_mutexes</i></b> default to <b><i>8</i></b> for multi-threaded programs in the function <b><i>omalloc_init()</i></b>. Here, for single-threaded, the value of variable <b><i>from_rthread</i></b> is <b><i>0</i></b> 
<p>Then, it is checking for <b><i>MALLOC_PAGEMASK</i></b> bit for <b><i>malloc_readonly</i></b> address or simply we can say that it is checking the last 12 bits of the <b><i>malloc_readonly</i></b> structure address and all 12 bits must be <b><i>0</i></b> to apply perm bit <b><i>PROT_READ</i></b> and <b><i>PROT_WRITE</i></b>. I would also say it is also checking for even address 
<p>After that, there is a loop till the <b><i>nmutexes</i></b> which is 2 for our case, single-threaded. For single-threaded programs, it maintains two malloc dir_info pools as indicates from the variable <b><i>nmutexes</i></b>. One for <b><i>MAP_CONCEALED</i></b> memory (#0) and one for regular (#1).
For multi-threaded porgram more pools are created. This is to avoid contention, accesses to diffrent pools can run concurently [ref. [1] <a href="https://marc.info/?l=openbsd-tech&m=154521318606876&w=2"> related to multi-pools - mailing list</a> [2] <a href="https://github.com/libressl-portable/openbsd/commit/55874ab3542715ce7e5c5e8ec0d6e1d7576a29a6#diff-5ce2636352a42c4e4a687c72939dbec9">github diff for more pools</a>]
<p><b><i>omalloc_poolinit(&d, MAP_CONCEAL);</i></b> when <b><i>if i == 0</i></b> for MAP_CONCEALED memory and <b><i>else</i></b>, <b><i>omalloc_poolinit(&d, 0);</i></b> for regular memory pools. 
<p>omalloc_poolinit()</i></b> code given below:
<pre>
<code>
473 static void
474 omalloc_poolinit(struct dir_info **dp, int mmap_flag)
475 {
476         char *p;
477         size_t d_avail, regioninfo_size;
478         struct dir_info *d;
479         int i, j;
480
481         /*
482          * Allocate dir_info with a guard page on either side. Also
483          * randomise offset inside the page at which the dir_info
484          * lies (subject to alignment by 1 << MALLOC_MINSHIFT)
485          */
486         if ((p = MMAPNONE(DIR_INFO_RSZ + (MALLOC_PAGESIZE * 2), mmap_flag)) ==
487             MAP_FAILED)
488                 wrterror(NULL, "malloc init mmap failed");
489         mprotect(p + MALLOC_PAGESIZE, DIR_INFO_RSZ, PROT_READ | PROT_WRITE);
490         d_avail = (DIR_INFO_RSZ - sizeof(*d)) >> MALLOC_MINSHIFT;
491         d = (struct dir_info *)(p + MALLOC_PAGESIZE +
492             (arc4random_uniform(d_avail) << MALLOC_MINSHIFT));
493
494         rbytes_init(d);
495         d->regions_free = d->regions_total = MALLOC_INITIAL_REGIONS;
496         regioninfo_size = d->regions_total * sizeof(struct region_info);
497         d->r = MMAP(regioninfo_size, mmap_flag);
498         if (d->r == MAP_FAILED) {
499                 d->regions_total = 0;
500                 wrterror(NULL, "malloc init mmap failed");
501         }
502         for (i = 0; i <= MALLOC_MAXSHIFT; i++) {
503                 LIST_INIT(&d->chunk_info_list[i]);
504                 for (j = 0; j < MALLOC_CHUNK_LISTS; j++)
505                         LIST_INIT(&d->chunk_dir[i][j]);
506         }
507         STATS_ADD(d->malloc_used, regioninfo_size + 3 * MALLOC_PAGESIZE);
508         d->mmap_flag = mmap_flag;
509         d->malloc_junk = mopts.def_malloc_junk;
510         d->malloc_cache = mopts.def_malloc_cache;
511         d->canary1 = mopts.malloc_canary ^ (u_int32_t)(uintptr_t)d;
512         d->canary2 = ~d->canary1;
513
514         *dp = d;
515 }
</pre>
</code>
<font size="2">
	<p align="center">code snippet #06
</font>
<p><b><i>omalloc_poolinit(struct dir_inf **dp, int mmap_flag)</i></b> does the following things:
<ul>
	<li><p>After some basic variable declarations, first it maps page into memory using mmap(2) in MMAPNONE(sz, f) where sz is the size and f is the flag</li>
<pre>
<code>
96 #define MMAPNONE(sz,f)  mmap(NULL, (sz), PROT_NONE, \
97     MAP_ANON | MAP_PRIVATE | (f), -1, 0)
</pre>
</code>
<font size="2">
	<p align="center">MMAPNONE(sz, f)
</font>
	<li><p>So, as from the above macro defination, we can see that the first parameter of mmap(2), that is, addr is <b><i>NULL</i></b></li>
<pre>
<code>
     The mmap() function causes the contents of fd, starting at offset, to be
     mapped in memory at the given addr.  The mapping will extend at least len
     bytes, subject to page alignment restrictions.

     The addr argument describes the address where the system should place the
     mapping.  If the MAP_FIXED flag is specified, the allocation will happen
     at the specified address, replacing any previously established mappings
     in its range.  Otherwise, the mapping will be placed at the available
     spot at addr; failing that it will be placed "close by".  If addr is NULL
     the system can pick any address.  Except for MAP_FIXED mappings, the
     system will never replace existing mappings.

     The len argument describes the minimum amount of bytes the mapping will
     span.  Since mmap() maps pages into memory, len may be rounded up to hit
     a page boundary.  If len is 0, the mapping will fail with EINVAL.
</pre>
</code>
<font size="2">
	<p align="center"><a href="https://man.openbsd.org/mmap.2">mmap(2)</a> man page
</font>
	<li><p>So below are the figures that I got it from gdb during debugging through execution</li>
<pre>
<code>
sz = DIR_INFO_RSZ + (MALLOC_PAGESIZE * 2)
where DIR_INFO_RSZ = ((sizeof(struct dir_info) + MALLOC_PAGEMASK) & ~MALLOC_PAGEMASK)
MALLOC_PAGEMASK = 4095 bytes
MALLOC_PAGESIZE = 4096 bytes
So, DIR_INFO_RSZ becomes (4284 + 4095) & ~4095 = 8192 bytes
and sz becomes 8192 + (4096 * 2) = 16384 bytes
and, f = MMAP_CONCEAL; which means it prevents from leaking the information and also it excludes the mapping from core dumps
</code>
</pre>
<font size="2">
	<p align="center">page calculations
</font>
	<li><p>So, as from the above page mapping calculations, DIR_INFO_RSZ indicates that to store the <b><i>dir_info</i></b> structure we need <b><i>2 pages</i></b> and allocate <b><i> 4 pages PROT_NONE</i></b> using MMAPNONE with flag as "MAP_CONCEAL", which can be seen in [code snippet #06]</li>
	<li><p>Then, making two middle pages R/W which can be seen from the macro value of DIR_INFO_RSZ, 2 pages</li>
	<li><p>then, calculate the <b><i>d_avail</i></b> to randomise offset inside the page at which the <b><i>dir_info</i></b> lies (subject to alignment by 1 << MALLOC_MINSHIFT)</li>
<pre>
<code>
d_avail = (8192 - 4824) >> 4 = 3368 >> 4 = 210
</pre>
</code>
	<li><p> the d_avail is 210, now calculate offset, d </li>
<pre>
<code>
d = (struct dir_info *)(p + MALLOC_PAGESIZE + (arc4random_uniform(d_avail) << MALLOC_MINSHIFT));
</code>
</pre>
	<li><p>So, as mentioned by the developer <b><i><a href="https://twitter.com/ottom6k">Otto@</a></i></b> in the <a href="https://marc.info/?l=openbsd-tech&m=158408023212237&w=2">mailing list</a> that the <b><i>dir_info</i></b> structure ends up on an aligned address somewhere in the middle pages on an offset between 0 and (210<<4) = 0..3360, counting from the start of the two middle pages.So, it becomes like d = [p + MALLOC_PAGESIZE + (0..3360)], where (0..3360) is the offset value from 0 to 3360 max</li>
	<li><p>As from the code, in my opinion, it looks like there is no guard page bydefault on the both the sides, however, it is there only one side but after discussing with the developer <b><i><a href="https://twitter.com/ottom6k">Otto@</a></i></b>. He said that <b><i>dir_info</i></b> is special and having a guard page on both sides for regular allocation can be done, but would waste more pages. He mentioned to note that <b>allocations are already spread throughout the address space, so it is very likely that an allocation is surrounded by unmapped pages</b>. So, finally he mentioned that there will be guard page on each side
	<li><p>then it initializes random bytes using the <b><i>rbytes_init(d)</i></b> function. Code for the same give below:</li>
	<pre>
	<code>
303 static void
304 rbytes_init(struct dir_info *d)
305 {
306         arc4random_buf(d->rbytes, sizeof(d->rbytes));
307         /* add 1 to account for using d->rbytes[0] */
308         d->rbytesused = 1 + d->rbytes[0] % (sizeof(d->rbytes) / 2);
309 }
	</code>
	</pre>
<font size="2">
	<p align="center">rbytes_init(struct dir_info *d)
</font>
	<li><p>It is clearly seen from the above code that it is filling the <b><i>d->rbytes</i></b> with the random bytes using the <b><i>arc4random_buf()</i></b>. Then, keeps the tracks/count of the rbytes used with <b><i>d->rbytesused</i></b></li>
	<li><p>After that as from the [code snippet #06], it is initializing the default values for some of the structure members, <b><i>d->regions_free = dir->regions_total = MALLOC_INTIAL_REGIONS;</i></b> where the value of macro <b><i>MALLOC_INITIAL_REGIONS</i></b> is <b><i>512</i></b>. Also, calculates the total region_info size, <b><i>regioninfo_size = d->regions_total * sizeof(struct region_info);</i></b></li>
	<pre>
	<code>
105 struct region_info {
106         void *p;                /* page; low bits used to mark chunks */
107         uintptr_t size;         /* size for pages, or chunk_info pointer */
108 #ifdef MALLOC_STATS
109         void *f;                /* where allocated from */
110 #endif
111 };
	</code>
	</pre>
<font size="2">
	<p align="center">struct region_info
</font>
	<li><p> The structure <b><i>struct region_info</i></b> is used to keep track of mmap’ed regions by storing their address and size into a hash table as mentioned in the <a href="https://www.openbsd.com.au/papers/eurobsdcon2009/otto-malloc.pdf">slides</a> of <b><i><a href="https://twitter.com/ottom6k">Otto@</a></i></b></li>
	<li><p>then, it maps pages of size <i>regioninfo_size</i> for regions with the flag <b><i>MAP_CONCEAL</i></b> and assigns it to <b><i>d->r</i></b> and then checks if mapping failed</li>
	<li><p> And, one more query that I had during understanding the source code of malloc(3) is about the code snippet given below [taken from the code snippet# 06]</li>
	<pre>
	<code>
...
...
...
502         for (i = 0; i <= MALLOC_MAXSHIFT; i++) {
503                 LIST_INIT(&d->chunk_info_list[i]);
504                 for (j = 0; j < MALLOC_CHUNK_LISTS; j++)
505                         LIST_INIT(&d->chunk_dir[i][j]);
506         }
...
...
...
	</code>
	</pre>
	<font size="2">
		<p align="center">code snippet - lists creation to allow randomization
	</font>
	<li><p><b><i>What is the purpose of creating these many linked lists?</i></b> So, after discussing with the <b><i><a href="https://twitter.com/ottom6k">Otto@</a></i></b>, I came to know that these many lists is used to allow more randomization. As <b><i><a href="https://twitter.com/ottom6k">Otto@</a></i></b> said "More than one list of free chunk pages per chunk size is maintained to allow for more randomization."</li>
	<li><p>So, in short the above nested for loops will create 12 chunk_info_list where i is 0 to 11 and for each and every ith index there is j, so as per that,</li>
	<pre>
	<code>
chunk_info_list[0]
	chunk_dir[0][0]
	chunk_dir[0][1]
	chunk_dir[0][2]
	chunk_dir[0][3]
...
...
...
chunk_info_list[11]
	chunk_dir[11][0]
	chunk_dir[11][1]
	chunk_dir[11][2]
	chunk_dir[11][3]

...
...
...
	</code>
	</pre>
	<li><p>One can also allow more randomization by increasing the <b><i>MALLOC_CHUNK_LISTS</i></b> but at the cost of overhead. Increasing the <b><i>MALLOC_MAXSHIFT</i></b> is not possible because it is the shift of the max chunk size that fits in a page. We will see later how these lists heps to achieve randomization</li>
	<li><p>then, adds and updated the <b><i>d->malloc_used</i></b> for dumping the malloc stats information</li> 
	<li>then, updated the default initialization of variables given below:</li>
	<pre>
	<code>
...
...
...
508         d->mmap_flag = mmap_flag;
509         d->malloc_junk = mopts.def_malloc_junk;
510         d->malloc_cache = mopts.def_malloc_cache;
511         d->canary1 = mopts.malloc_canary ^ (u_int32_t)(uintptr_t)d;
512         d->canary2 = ~d->canary1;
513
514         *dp = d;
515 }
	/* where it is already mentioned above code snippets that mopts.def_malloc_junk is 1 and
	 *  mopts.def_malloc_cache is 64, already initialized default values in omalloc_init() 
	 */
	</code>
	</pre>
	<font size="2">
		<p align="center">code snippet #07
	</font>
	<li><p>then, <i>dir_info</i> uses two canaries. There calculation is very easy. Whatever the address of <b><i>d</i></b> ( struct dir_info *d) just typecast it to <b><i>(u_int32_t)(uintptr_t)</i></b> and <b>XOR</b> it with <b><i>mopts.malloc_canary</i></b> and assign the result to <b><i>d->canary1</i></b> and then compute the <b><i>not (~)</i></b> of <b><i>d->canary1</i></b> then assign the result to <b><i>d->canary2</i></b> or in simpler words, convert into binary then take each bit and flips them to their logical opposite. convert 1's to 0's and vice versa then convert it to hex and assign it to <b><i>d->canary2</i></b></li>
	<li><p>finally assign the initialized dir_info structure <b>d</b> to <b><i>*dp</i></b></li>
</ul>
<p>We are still in function <b><i>_malloc_init(int from_rthreads)</i></b>, so, as per the [code snippet #03], for <b><i>i == 0</i></b>, we have completed the function <b><i>omalloc_poolinit(&d, MAP_CONCEAL);</i></b>, now after that, <b><i>d->malloc_junk = 2;</i></b> and <b><i>d->malloc_cache = 0;</i></b> 
<p>Then, it saves the index <b>i</b> to <b><i>d->mutex</i></b> and stored the initialized MAP_CONCEALED pool to <b><i>mopts.malloc_pool[i] = d;</i></b>
<p>The value of <b>nmutexes</b> is 2, so, now loop will again do the whole same operations for index <b>i == 1</b> or we can say for <b>i != 0</b>.So, this time also it invokes <b><i>omalloc_poolinit(&d, 0)</i></b> but with no flag, [remember, last time it was MAP_CONCEAL, this time is 0]. So, <b><i>omalloc_poolinit(&d, 0)</i></b> performs the same operations but only the diff is with no flag value or with flag value 0
<p>After completion of function <b><i>omalloc_poolinit(&d, 0)</i></b>, it sets junk value to default junk value and same for malloc_cache, that is, <b><i>d->malloc_junk = mopts.def_malloc_junk;</i></b> and <b><i>d->malloc_cache = mopts.def_malloc_cache;</i></b>. Now, again for <b>i = 1</b> it does the same thing, that is, saving the new index <b>1</b> to <b><i>d->mutex</i></b> and stores the pool to <b><i>mopts.malloc_pool[i] = d</i></b>
<p>So, now <b>mopts.malloc_pool</b> has two pools, <b><i>mopts.malloc_pool[0]</i></b> and <b><i>mopts.malloc_pool[1]</i></b>
<p>Next, it checks for multi-threading from variable <b>from_rthreads</b>, if the value is non-zero then it sets <b><i>mopts.malloc_mt = 1</i></b> which shows that program is multi-threaded but for our case it is zero (0), so, it doesn't go in that code flow and then the else code flow executes and sets <b><i>mopts.internal_funcs = 1</i></b>, from the structure <b><i>malloc_readonly</i></b>, it shows that setting <b>internal_funcs</b> means to use better function like recallocarray/freezero but I haven't seen them for our case, maybe they have used it for some other scenarios like in case of calloc, etc. <a href="https://marc.info/?l=openbsd-tech&m=148846616030488&w=2">recallocarray(3) - mailing list</a>
<p>Finally it sets the perms to readonly, to prevent further tampering with them, again it checks last 12 bits and if they are 0 then it sets perms to PROT_READ, and <b><i>_malloc_init(0)</i></b> completed
<p>Now, we go back to the PROGLOGUE macro code in the [code snippet #01], I have pasted the code again below:
<pre>
<code>
1256 #define PROLOGUE(p, fn)                 \
1257         d = (p);                        \
1258         if (d == NULL) {                \
1259                 _malloc_init(0);        \
1260                 d = (p);                \
1261         }                               \
1262         _MALLOC_LOCK(d->mutex);         \
1263         d->func = fn;                   \
1264         if (d->active++) {              \
1265                 malloc_recurse(d);      \
1266                 return NULL;            \
1267         }                               \
</code>
</pre>
<p>So, as from the PROLOGUE code, we can see that we have completed the <b><i>malloc_init(0)</i></b>.Now, if we remember correctly, here p refers to the function <b><i>getpool()</i></b>, calls getpool() function again and this time also due to single-threaded program, it returns <b><i>mopts.malloc_pool[1]</i></b>, which has the regular pool, not MAP_CONCEALED one, return the same to <b>d</b> then malloc_lock and assigns fn to <b><i>d->fn</i></b>, here fn means "malloc". It checks and incremented the <b><i>d->active</i></b> and doesn't go inside the if code-flow due to 0 value of <b>d->active</b>
<p>As one can see from the [code snippet #00], I have pasted it again below
<pre>
<code>
1277 void *
1278 malloc(size_t size)
1279 {
1280         void *r;
1281         struct dir_info *d;
1282         int saved_errno = errno;
1283
1284         PROLOGUE(getpool(), "malloc")
1285         r = omalloc(d, size, 0, CALLER);
1286         EPILOGUE()
1287         return r;
1288 }
</code>
</pre>
<p> From line no. 1285, we can see that after PROLOGUE it calls <b><i>omalloc(d, size, CALLER)</i></b>. Code for <b><i>omalloc(d, size, CALLER)</i></b> given below:
<pre>
<code>
1126	static void *
1127	omalloc(struct dir_info *pool, size_t sz, int zero_fill, void *f)
1128	{
1129		void *p;
1130		size_t psz;
1131
1132		if (sz > MALLOC_MAXCHUNK) {
1133			if (sz >= SIZE_MAX - mopts.malloc_guard - MALLOC_PAGESIZE) {
1134				errno = ENOMEM;
1135				return NULL;
1136			}
1137			sz += mopts.malloc_guard;
1138			psz = PAGEROUND(sz);
1139			p = map(pool, NULL, psz, zero_fill);
1140			if (p == MAP_FAILED) {
1141				errno = ENOMEM;
1142				return NULL;
1143			}
1144			if (insert(pool, p, sz, f)) {
1145				unmap(pool, p, psz, 0, 0);
1146				errno = ENOMEM;
1147				return NULL;
1148			}
1149			if (mopts.malloc_guard) {
1150				if (mprotect((char *)p + psz - mopts.malloc_guard,
1151				    mopts.malloc_guard, PROT_NONE))
1152					wrterror(pool, "mprotect");
1153				STATS_ADD(pool->malloc_guarded, mopts.malloc_guard);
1154			}
1155
1156			if (MALLOC_MOVE_COND(sz)) {
1157				/* fill whole allocation */
1158				if (pool->malloc_junk == 2)
1159					memset(p, SOME_JUNK, psz - mopts.malloc_guard);
1160				/* shift towards the end */
1161				p = MALLOC_MOVE(p, sz);
1162				/* fill zeros if needed and overwritten above */
1163				if (zero_fill && pool->malloc_junk == 2)
1164					memset(p, 0, sz - mopts.malloc_guard);
1165			} else {
1166				if (pool->malloc_junk == 2) {
1167					if (zero_fill)
1168						memset((char *)p + sz - mopts.malloc_guard,
1169						    SOME_JUNK, psz - sz);
1170					else
1171						memset(p, SOME_JUNK,
1172						    psz - mopts.malloc_guard);
1173				} else if (mopts.chunk_canaries)
1174					fill_canary(p, sz - mopts.malloc_guard,
1175					    psz - mopts.malloc_guard);
1176			}
1177
1178		} else {
1179			/* takes care of SOME_JUNK */
1180			p = malloc_bytes(pool, sz, f);
1181			if (zero_fill && p != NULL && sz > 0)
1182				memset(p, 0, sz);
1183		}
1184
1185		return p;
1186	}
</code>
</pre>
<font size="2">
	<p align="center">code snippet #08
</font>
<p><b><i>omalloc(struct dir_info *pool, size_t sz, int zero_fill, void *f);</i></b> does the following things...
<ul>
	<li><p>There are two code flow paths, <b>1st</b>, <b><i>if ( sz > MALLOC_MAXCHUNK)</i></b>. I have used size <b>8</b> in the sample code, so it won't go to this code flow path, but still I am going to explain but not in-depth. So, first it  checks if the size is greater than the <b><i>MALLOC_MAXCHUNK</i></b>, which is 4095. If size is less, then it uses <b>2nd</b> code flow, that is, it calls <b><i>malloc_bytes(pool, sz, f);</i></b> which we will see later, for now I am going to cover the case when size of greater in the following points</li>
	<ul>
		<li><p>After checking the size with MALLOC_MAXCHUNK then it checks if the requested size is bigger than SIZE_MAX (excluding mopts.malloc_guard and MALLOC_PAGESIZE), if yes, then it sets errno to ENOMEM</li>
		<li><p>Then, it adds the malloc_guard value to requested size, then it rounds the page to multiple of pagesize, that is, if requested size is <= 4096 then it rounds it to 4096 but if requested size is 4097 then it rounds it to 8192</li>
		<li><p>Then, it maps the page by taking provided <b><i>pool</i></b> as hint address then check if it fails</li>
		<li> Then, it uses <b><i>insert(pool, p, sz, f);</i></b> function call to keep track of mmap’ed regions by storing their address and size into a hash table, we will se more in-depth code flow later, if it fails to insert then it unmaps the page and return ENOMEM</li>
		<li><p>Then, it checks for malloc_guard page option, if it sets then it adds a guarded page as per the size mentioned by malloc_guard variable with PROT_NONE perms bit and then it adds the information for stats</li>
		<li><p>Then, it checks for <b><i>MALLOC_MOVE_COND</i></b>, if the condition is true then it shifts the allocations towards the end, as mentioned in the source code comment,</li>
		<pre>
		<code>
70 /*
71  * We move allocations between half a page and a whole page towards the end,
72  * subject to alignment constraints. This is the extra headroom we allow.
73  * Set to zero to be the most strict.
74  */
75 #define MALLOC_LEEWAY           0
76 #define MALLOC_MOVE_COND(sz)    ((sz) - mopts.malloc_guard <            \
77                                     MALLOC_PAGESIZE - MALLOC_LEEWAY)
78 #define MALLOC_MOVE(p, sz)      (((char *)(p)) +                        \
79                                     ((MALLOC_PAGESIZE - MALLOC_LEEWAY - \
80                                     ((sz) - mopts.malloc_guard)) &      \
81                                     ~(MALLOC_MINSIZE - 1)))
		</code>
		</pre>
		<li><p>After checking for condition, first, it checks for junking value, that is,<b><i>pool->malloc_junk == 2</i></b> if it equals <b>then</b> it fills the mmap'ed page <b>p</b> with <b><i>SOME_JUNK</i></b> which has bits <b><i>0xdb</i></b>, then as previously mentioned that it shifts the allocation towards end with macro <b>MALLOC_MOVE(p, sz)</b>, then later on it checks if zero-filling requires, if it requires then if fills the same JUNKed filled page with zeroes</li>
		<li><p>But, if the <b><i>MALLOC_MOVE_COND</i></b>, condition is not true then it simple checks for junking value, that is, <b>pool->malloc_junk == 2</b>, if it equals to <b>2</b> then it checks for zero filling and if it requires then it fills from the address as mentioned in the code snippet given below if { ... }, and if zero filling not requires then it simply fills with SOME_JUNK as mentioned in the else { ... } code flow</li>
		<pre>
		<code>
		...
		...
		...
1166				if (pool->malloc_junk == 2) {
1167					if (zero_fill)
1168						memset((char *)p + sz - mopts.malloc_guard,
1169						    SOME_JUNK, psz - sz);
1170					else
1171						memset(p, SOME_JUNK,
1172						    psz - mopts.malloc_guard);
		</code>
		</pre>
		<li><p>So, if the junking value is equals to 2, that is, <b><i>pool->malloc_junk == 2</i></b>, this code flow is covered in the previous point but if it fails or not equals to 2 then it checks for canaries, that is, <b><i> else if (mopts.chunk_canaries) </i></b> then it calls the <b>fill_canary</b> function to filling the canaries</li>
	</ul>
	<li><p>1st code flow completed, now <b>2nd code flow</b>, that is, <b><i>if (sz < MALLOC_MAXCHUNK)</i></b> means if requested size is less than the MALLOC_MAXCHUNK, previously in 1st code flow it was greater than the MALLOC_MAXCHUNK</li> 
	<ul>
		<li><p> it calls the function <b><i>malloc_bytes(pool, sz, f);</i></b> and the source code for the same given below</li>
		<pre>
		<code>
948	/*
949	 * Allocate a chunk
950	 */
951	static void *
952	malloc_bytes(struct dir_info *d, size_t size, void *f)
953	{
954		u_int i, r;
955		int j, listnum;
956		size_t k;
957		u_short	*lp;
958		struct chunk_info *bp;
959		void *p;
960	
961		if (mopts.malloc_canary != (d->canary1 ^ (u_int32_t)(uintptr_t)d) ||
962		    d->canary1 != ~d->canary2)
963			wrterror(d, "internal struct corrupt");
964	
965		j = find_chunksize(size);
966	
967		r = ((u_int)getrbyte(d) << 8) | getrbyte(d);
968		listnum = r % MALLOC_CHUNK_LISTS;
969		/* If it's empty, make a page more of that size chunks */
970		if ((bp = LIST_FIRST(&d->chunk_dir[j][listnum])) == NULL) {
971			bp = omalloc_make_chunks(d, j, listnum);
972			if (bp == NULL)
973				return NULL;
974		}
975	
976		if (bp->canary != (u_short)d->canary1)
977			wrterror(d, "chunk info corrupted");
978	
979		i = (r / MALLOC_CHUNK_LISTS) & (bp->total - 1);
980	
981		/* start somewhere in a short */
982		lp = &bp->bits[i / MALLOC_BITS];
983		if (*lp) {
984			j = i % MALLOC_BITS;
985			k = ffs(*lp >> j);
986			if (k != 0) {
987				k += j - 1;
988				goto found;
989			}
990		}
991		/* no bit halfway, go to next full short */
992		i /= MALLOC_BITS;
993		for (;;) {
994			if (++i >= bp->total / MALLOC_BITS)
995				i = 0;
996			lp = &bp->bits[i];
997			if (*lp) {
998				k = ffs(*lp) - 1;
999				break;
1000			}
1001		}
1002	found:
1003	#ifdef MALLOC_STATS
1004		if (i == 0 && k == 0) {
1005			struct region_info *r = find(d, bp->page);
1006			r->f = f;
1007		}
1008	#endif
1009	
1010		*lp ^= 1 << k;
1011	
1012		/* If there are no more free, remove from free-list */
1013		if (--bp->free == 0)
1014			LIST_REMOVE(bp, entries);
1015	
1016		/* Adjust to the real offset of that chunk */
1017		k += (lp - bp->bits) * MALLOC_BITS;
1018	
1019		if (mopts.chunk_canaries && size > 0)
1020			bp->bits[bp->offset + k] = size;
1021	
1022		k <<= bp->shift;
1023	
1024		p = (char *)bp->page + k;
1025		if (bp->size > 0) {
1026			if (d->malloc_junk == 2)
1027				memset(p, SOME_JUNK, bp->size);
1028			else if (mopts.chunk_canaries)
1029				fill_canary(p, size, bp->size);
1030		}
1031		return p;
1032	}
  		</code>
		</pre>
		<font size="2">
			<p align="center">code snippet #09
		</font>
		<li><p><b><i>malloc_bytes(pool, sz, f);</i></b> is used to allocate a chunk. After some basic variable declaration, it checks for internal struct corruption with canaries of <b>d</b> and <b>mopts.malloc_canary</b> as mentioned and calculated in the [code snippet #07]</li>
		<li><p>then, it finds the chunk size with the function <b><i>find_chunksize(size);</i></b>. Code given below</li>
		<pre>
		<code>
 919 static int
 920 find_chunksize(size_t size)
 921 {
 922         int r;
 923
 924         /* malloc(0) is special */
 925         if (size == 0)
 926                 return 0;
 927
 928         if (size < MALLOC_MINSIZE)
 929                 size = MALLOC_MINSIZE;
 930         size--;
 931
 932         r = MALLOC_MINSHIFT;
 933         while (size >> r)
 934                 r++;
 935         return r;
 936 }
		</code>
		</pre>
		<font size="2">
			<p align="center">code snippet #10
		</font>
		<li><p>As from the [code snippet #10], first it will check if given size is <b>0</b> then it returns <b>0</b>, then it checks if size is less than MALLOC_MINSIZE then it sets size to MALLOC_MINSIZE, else, it decrements the size and sets <b><i>r = MALLOC_MINSHIFT;</i></b>  and the value of MALLOC_MINSHIFT is <b>4</b>. Then it right shifts the <b>size</b> by <b>r</b> and it keeps incrementing the <b>r</b> till right shifting results becomes zero, then returns <b>r</b>. In our case, the size is 8, which is less than MALLOC_MINSIZE and then due to it is less than MALLOC_MISIZE, it sets the size to MALLOC_MINSIZE, which is 16, then it decrements and it becomes 15 and <b>15 >> 4</b>, r is MALLOC_MINSHIFT, which is 4. So, output of <b>15 >>4</b> is 0. So, it returns r, which is 4</li>
		<li><p>As we can see from the [code snippet #9], after find_chunksize(size), it calls <b>((u_int)getrbyte(d) << 8) | getrbyte(d);</b>, so, getrbyte(d) given below:</li>
		<pre>
		<code>
 311 static inline u_char
 312 getrbyte(struct dir_info *d)
 313 {
 314         u_char x;
 315 
 316         if (d->rbytesused >= sizeof(d->rbytes))
 317                 rbytes_init(d);
 318         x = d->rbytes[d->rbytesused++];
 319         return x;
 320 }
 		</code>
		</pre>
		<font size="2">
			<p align="center">code snippet #11
		</font>
		<li><p>So, in the above code, if <i>d->rbytesused >= sizeof(d->rbytes)</i> then it initializes the random bytes using <i>rbytes_init(d)</i>, else, it assigns x to <i>d->rbytes[d->rbytesused]</i> and returns the same. So as per the name indicates, I think it as getrbyte() means get-random-byte(), basically the whole line <b><i>r = ((u_int)getrbyte(d) << 8) | getrbyte(d);</i></b> does the following stuff...</li>
		<pre>
		<code>
		get-random-byte then left shits by 8 then OR'ed with again some random byte
		let's suppose,
		1) a =  get-random-bytes
		2) left shift a by 8 
		3) b = get-random-bytes
		4) r = a | b
		for example, 0xd4 -> 0xd400 -> 0xd4cb, so r = 0xd4cb
		</code>
		</pre>
		<li><p>then it finds the listnum, <b><i>listnum = r % MALLOC_CHUNK_LISTS;</i></b>, where MALLOC_CHUNK_LISTS is 4</li>

		<li><p>As from the [code snippet - lists creation to allow randmization], we have seen that there is nested for loops which creates lists, helpful to allow randomization. So, here we can see that it randomly chooses the created lists for allocation of chunk_info</li>
		<li><p>Then, it chooses some random list and makes it first list, now if the list is empty, that is, head is NULL then it calls function <b><i>omalloc_make_chunks(d, j, listnum);</i></b>to allocate chunks. Code for <b><i>omalloc_make_chunks</i></b> given below</li>
		<pre>
		<code>
 885 /*
 886  * Allocate a page of chunks
 887  */
 888 static struct chunk_info *
 889 omalloc_make_chunks(struct dir_info *d, int bits, int listnum)
 890 {
 891         struct chunk_info *bp;
 892         void *pp;
 893
 894         /* Allocate a new bucket */
 895         pp = map(d, NULL, MALLOC_PAGESIZE, 0);
 896         if (pp == MAP_FAILED)
 897                 return NULL;
 898
 899         /* memory protect the page allocated in the malloc(0) case */
 900         if (bits == 0 && mprotect(pp, MALLOC_PAGESIZE, PROT_NONE) == -1)
 901                 goto err;
 902
 903         bp = alloc_chunk_info(d, bits);
 904         if (bp == NULL)
 905                 goto err;
 906         bp->page = pp;
 907
 908         if (insert(d, (void *)((uintptr_t)pp | (bits + 1)), (uintptr_t)bp,
 909             NULL))
 910                 goto err;
 911         LIST_INSERT_HEAD(&d->chunk_dir[bits][listnum], bp, entries);
 912         return bp;
 913
 914 err:
 915         unmap(d, pp, MALLOC_PAGESIZE, 0, d->malloc_junk);
 916         return NULL;
 917 }
		</code>
		</pre>
		<font size="2">
			<p align="center">code snippet #12
		</font>
</body>
</html>
