<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Tale of OpenBSD secure memory allocator internals - malloc(3) :: bsdb0y</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Let&#39;s dive into the core internals through reading the code and debugging of one of the secure memory allocator - OpenBSD Memory allocator" />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://bsdb0y.github.io/posts/tale_of_openbsd_memory_allocator_internals/" />




<link rel="stylesheet" href="https://bsdb0y.github.io/assets/style.css">

  <link rel="stylesheet" href="https://bsdb0y.github.io/assets/blue.css">






<link rel="apple-touch-icon" href="https://bsdb0y.github.io/img/apple-touch-icon-192x192.png">

  <link rel="shortcut icon" href="https://bsdb0y.github.io/img/favicon/blue.png">



<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="bsdb0y" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Tale of OpenBSD secure memory allocator internals - malloc(3)">
<meta property="og:description" content="Let&#39;s dive into the core internals through reading the code and debugging of one of the secure memory allocator - OpenBSD Memory allocator" />
<meta property="og:url" content="https://bsdb0y.github.io/posts/tale_of_openbsd_memory_allocator_internals/" />
<meta property="og:site_name" content="bsdb0y" />

  <meta property="og:image" content="https://bsdb0y.github.io/">

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">


  <meta property="article:published_time" content="2020-03-28 00:00:00 &#43;0000 UTC" />












</head>
<body class="blue">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    bsdb0y
  </div>
</a>

    </div>
    
      <div class="menu-trigger">menu</div>
    
  </div>
  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/bugs">Bugs</a></li>
        
      
      
    

    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/bugs">Bugs</a></li>
      
    
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="https://bsdb0y.github.io/posts/tale_of_openbsd_memory_allocator_internals/">Tale of OpenBSD secure memory allocator internals - malloc(3)</a></h1>
  <div class="post-meta">
    
      <span class="post-date">
        2020-03-28
        
      </span>
    
    
      <span class="post-author">:: bsdb0y</span>
    
    
      <span class="post-reading-time">:: 47 min read (9915 words)</span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="https://bsdb0y.github.io/tags/openbsd/">openbsd</a>&nbsp;
    
    #<a href="https://bsdb0y.github.io/tags/malloc/">malloc</a>&nbsp;
    
    #<a href="https://bsdb0y.github.io/tags/internals/">internals</a>&nbsp;
    
  </span>
  
  


  

  <div class="post-content"><div>
        <p>Hi there,</p>
<p>It&rsquo;s been a long time since I have written anything, so, continuing with the journey of reading and exloring the OpenBSD source codes with my friend debugger.
This time it is about OpenBSD <a href="/https://man.openbsd.org/malloc.3">malloc(3)</a>, secure memory allocator</p>
<p>I will try to keep it as <strong><em>n</em></strong> part series due to lengthy content and this series will be mostly focussed on user-space code of <a href="/https://man.openbsd.org/malloc.3">malloc(3)</a> and friends</p>
<p>First of all, I would like to thanks <strong><em><a href="https://twitter.com/ottom6k">Otto Moerbeek</a></em></strong>, <strong><em><a href="https://twitter.com/canadianbryan">Bryan Steele</a></em></strong> and <strong><em>Fabien Romano</em></strong> for helping me to understand the <a href="https://man.openbsd.org/malloc.3">malloc(3)</a> internals and resolving my queries/doubts.</p>
<p>So, we should start without wasting much time&hellip; :)</p>
<p>Consider the following code-snippet to start our memory allocator journey on OpenBSD 6.6-stable <a href="https://man.openbsd.org/malloc.3">malloc(3)</a></p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span>
<span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv) {
    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>buff1 <span style="color:#f92672">=</span> NULL;
    buff1 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)malloc(<span style="color:#ae81ff">8</span>);
    strcpy(buff1, argv[<span style="color:#ae81ff">1</span>]);
    free(buff1);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></td></tr></table>
</div>
</div><p>Compile libc with debug symbols and turn off the optimization by compiling it with option &ldquo;-O0 -g&rdquo;.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">cd <span style="color:#960050;background-color:#1e0010">$</span>openbsd_src_directory
cd lib<span style="color:#f92672">/</span>libc
CFLAGS<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;-g -O0&#34;</span> CXXFLAGS<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;-g -O0&#34;</span> make obj
CFLAGS<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;-g -O0&#34;</span> CXXFLAGS<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;-g -O0&#34;</span> make
</code></pre></div><p>Used debugger for understanding the code internals instead of printf style debugging.</p>
<blockquote>
<p>For printf style debugging, one can use <a href="https://man.openbsd.org/dprintf.3">dprintf(3)</a> or <a href="https://man.openbsd.org/write.2">write(2)</a> calls to print anything but keep in mind that after installation of libc with printf it will print a lot of information for every executable, so, it is not a good idea to install it.<br>
<br>
Suggestion: one can either compile libc with or without printf statements and use LD_PRELOAD to load it and use debugger. With printf debugging one use the same LD_PRELOAD for the code snippet.</p>
</blockquote>
<p>From the code snippet jumped to <a href="https://man.openbsd.org/malloc.3">malloc(3)</a> defination from libc present in the file <em>/usr/src/lib/libc/stdlib/malloc.c:1278</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">1277</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>
<span style="color:#ae81ff">1278</span> <span style="color:#a6e22e">malloc</span>(size_t size)
<span style="color:#ae81ff">1279</span> {
<span style="color:#ae81ff">1280</span>         <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>r;
<span style="color:#ae81ff">1281</span>         <span style="color:#66d9ef">struct</span> dir_info <span style="color:#f92672">*</span>d;
<span style="color:#ae81ff">1282</span>         <span style="color:#66d9ef">int</span> saved_errno <span style="color:#f92672">=</span> errno;
<span style="color:#ae81ff">1283</span>
<span style="color:#ae81ff">1284</span>         PROLOGUE(getpool(), <span style="color:#e6db74">&#34;malloc&#34;</span>)
<span style="color:#ae81ff">1285</span>         r <span style="color:#f92672">=</span> omalloc(d, size, <span style="color:#ae81ff">0</span>, CALLER);
<span style="color:#ae81ff">1286</span>         EPILOGUE()
<span style="color:#ae81ff">1287</span>         <span style="color:#66d9ef">return</span> r;
<span style="color:#ae81ff">1288</span> }
</code></pre></div><p>As explained by the developer <strong><em><a href="https://twitter.com/ottom6k">Otto@</a></em></strong> in the <strong><em><a href="https://twitter.com/ottom6k/status/1236170000312012800">tweet on twitter</a></em></strong> that <strong><em>struct dir_info</em></strong> contains all the meta information malloc needs to keep track of what page regions have been allocated, which pages regions are in the free-cache and for pages of chunks which chunks are free and which are allocated. (UPDATE: tweet is no more available)</p>
<p>So, we can see that after some basic initialization, there are some macros, PROLOGUE and EPILOGUE</p>
<blockquote>
<p>prologue: english meaning of prologue refers to introductory or an opening to a story which sets the context and in computer terms, it referes the same meaning which means it set-up the necessary things to start execution.<br>
<br>
epilogue: in english, it means conclusion or ending part and in computer terms, it refers clearing up things which set-up by prologue.</p>
</blockquote>
<p>defination of PROLGOUE macro:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">1256</span> <span style="color:#960050;background-color:#1e0010">#</span>define PROLOGUE(p, fn)                 \
<span style="color:#ae81ff">1257</span>         d <span style="color:#f92672">=</span> (p);                        \
<span style="color:#ae81ff">1258</span>         <span style="color:#a6e22e">if</span> (d <span style="color:#f92672">==</span> NULL) {                \
<span style="color:#ae81ff">1259</span>                 _malloc_init(<span style="color:#ae81ff">0</span>);        \
<span style="color:#ae81ff">1260</span>                 d <span style="color:#f92672">=</span> (p);                \
<span style="color:#ae81ff">1261</span>         }                               \
<span style="color:#ae81ff">1262</span>         <span style="color:#a6e22e">_MALLOC_LOCK</span>(d<span style="color:#f92672">-&gt;</span>mutex);         \
<span style="color:#ae81ff">1263</span>         d<span style="color:#f92672">-&gt;</span>func <span style="color:#f92672">=</span> fn;                   \
<span style="color:#ae81ff">1264</span>         <span style="color:#a6e22e">if</span> (d<span style="color:#f92672">-&gt;</span>active<span style="color:#f92672">++</span>) {              \
<span style="color:#ae81ff">1265</span>                 malloc_recurse(d);      \
<span style="color:#ae81ff">1266</span>                 <span style="color:#66d9ef">return</span> NULL;            \
<span style="color:#ae81ff">1267</span>         }                               \
</code></pre></div><p>From the above malloc(3) defination, we can see that the first argument of PROLOGUE is function <code>getpool()</code> and second is the function string, that is, <code>&quot;malloc&quot;</code> and from the PROLOGUE macro expansion, we can see that it first calls <code>getpool()</code> and the defination of <code>getpool()</code> as mentioned</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">270</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">struct</span> dir_info <span style="color:#f92672">*</span>
<span style="color:#ae81ff">271</span> <span style="color:#a6e22e">getpool</span>(<span style="color:#66d9ef">void</span>)
<span style="color:#ae81ff">272</span> {
<span style="color:#ae81ff">273</span>         <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>mopts.malloc_mt)
<span style="color:#ae81ff">274</span>                 <span style="color:#66d9ef">return</span> mopts.malloc_pool[<span style="color:#ae81ff">1</span>];
<span style="color:#ae81ff">275</span>         <span style="color:#66d9ef">else</span>    <span style="color:#75715e">/* first one reserved for special pool */</span>
<span style="color:#ae81ff">276</span>                 <span style="color:#66d9ef">return</span> mopts.malloc_pool[<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> TIB_GET()<span style="color:#f92672">-&gt;</span>tib_tid <span style="color:#f92672">%</span>
<span style="color:#ae81ff">277</span>                     (mopts.malloc_mutexes <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)];
<span style="color:#ae81ff">278</span> }
</code></pre></div><p>from the above code defination, it first checks whether it has multi-threads or single-threads. And, in our case it is single threaded executable, so after <code>if</code> it returns <code>mopts.malloc_pool[1]</code> which is <code>NULL</code>.</p>
<p>then as per the PROLOGUE defination, it checks whether <code>d</code> is <code>NULL</code> or not. In our case it is <code>NULL</code> as at first it will always be <code>NULL</code> and after that it calls <code>__malloc_init(0)_</code> but when <code>d</code> is <code>not NULL</code> then it assigns <code>fn</code> to <code>d-&gt;func</code> and after that increment the <code>d-&gt;active</code> within <code>if</code> cond then calls <code>malloc_recurse(d)</code> and returns <code>NULL</code> but for our situation it is not the flow.</p>
<p>Defination of <code>_malloc_init(0)</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">1207</span> <span style="color:#66d9ef">void</span>
<span style="color:#ae81ff">1208</span> <span style="color:#a6e22e">_malloc_init</span>(<span style="color:#66d9ef">int</span> from_rthreads)
<span style="color:#ae81ff">1209</span> {
<span style="color:#ae81ff">1210</span>         u_int i, nmutexes;
<span style="color:#ae81ff">1211</span>         <span style="color:#66d9ef">struct</span> dir_info <span style="color:#f92672">*</span>d;
<span style="color:#ae81ff">1212</span> 
<span style="color:#ae81ff">1213</span>         _MALLOC_LOCK(<span style="color:#ae81ff">1</span>);
<span style="color:#ae81ff">1214</span>         <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>from_rthreads <span style="color:#f92672">&amp;&amp;</span> mopts.malloc_pool[<span style="color:#ae81ff">1</span>]) {
<span style="color:#ae81ff">1215</span>                 _MALLOC_UNLOCK(<span style="color:#ae81ff">1</span>);
<span style="color:#ae81ff">1216</span>                 <span style="color:#66d9ef">return</span>;
<span style="color:#ae81ff">1217</span>         }
<span style="color:#ae81ff">1218</span>         <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>mopts.malloc_canary)
<span style="color:#ae81ff">1219</span>                 omalloc_init();
<span style="color:#ae81ff">1220</span> 
<span style="color:#ae81ff">1221</span>         nmutexes <span style="color:#f92672">=</span> from_rthreads <span style="color:#f92672">?</span> mopts.malloc_mutexes : <span style="color:#ae81ff">2</span>;
<span style="color:#ae81ff">1222</span>         <span style="color:#66d9ef">if</span> (((uintptr_t)<span style="color:#f92672">&amp;</span>malloc_readonly <span style="color:#f92672">&amp;</span> MALLOC_PAGEMASK) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
<span style="color:#ae81ff">1223</span>                 mprotect(<span style="color:#f92672">&amp;</span>malloc_readonly, <span style="color:#66d9ef">sizeof</span>(malloc_readonly),
<span style="color:#ae81ff">1224</span>                     PROT_READ <span style="color:#f92672">|</span> PROT_WRITE);
<span style="color:#ae81ff">1225</span>         <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> nmutexes; i<span style="color:#f92672">++</span>) {
<span style="color:#ae81ff">1226</span>                 <span style="color:#66d9ef">if</span> (mopts.malloc_pool[i])
<span style="color:#ae81ff">1227</span>                         <span style="color:#66d9ef">continue</span>;
<span style="color:#ae81ff">1228</span>                 <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
<span style="color:#ae81ff">1229</span>                         omalloc_poolinit(<span style="color:#f92672">&amp;</span>d, MAP_CONCEAL);
<span style="color:#ae81ff">1230</span>                         d<span style="color:#f92672">-&gt;</span>malloc_junk <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
<span style="color:#ae81ff">1231</span>                         d<span style="color:#f92672">-&gt;</span>malloc_cache <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#ae81ff">1232</span>                 } <span style="color:#66d9ef">else</span> {
<span style="color:#ae81ff">1233</span>                         omalloc_poolinit(<span style="color:#f92672">&amp;</span>d, <span style="color:#ae81ff">0</span>);
<span style="color:#ae81ff">1234</span>                         d<span style="color:#f92672">-&gt;</span>malloc_junk <span style="color:#f92672">=</span> mopts.def_malloc_junk;
<span style="color:#ae81ff">1235</span>                         d<span style="color:#f92672">-&gt;</span>malloc_cache <span style="color:#f92672">=</span> mopts.def_malloc_cache;
<span style="color:#ae81ff">1236</span>                 }
<span style="color:#ae81ff">1237</span>                 d<span style="color:#f92672">-&gt;</span>mutex <span style="color:#f92672">=</span> i;
<span style="color:#ae81ff">1238</span>                 mopts.malloc_pool[i] <span style="color:#f92672">=</span> d;
<span style="color:#ae81ff">1239</span>         }
<span style="color:#ae81ff">1240</span> 
<span style="color:#ae81ff">1241</span>         <span style="color:#66d9ef">if</span> (from_rthreads)
<span style="color:#ae81ff">1242</span>                 mopts.malloc_mt <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#ae81ff">1243</span>         <span style="color:#66d9ef">else</span>
<span style="color:#ae81ff">1244</span>                 mopts.internal_funcs <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#ae81ff">1245</span> 
<span style="color:#ae81ff">1246</span>         <span style="color:#75715e">/*
</span><span style="color:#75715e">1247          * Options have been set and will never be reset.
</span><span style="color:#75715e">1248          * Prevent further tampering with them.
</span><span style="color:#75715e">1249          */</span>
<span style="color:#ae81ff">1250</span>         <span style="color:#66d9ef">if</span> (((uintptr_t)<span style="color:#f92672">&amp;</span>malloc_readonly <span style="color:#f92672">&amp;</span> MALLOC_PAGEMASK) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
<span style="color:#ae81ff">1251</span>                 mprotect(<span style="color:#f92672">&amp;</span>malloc_readonly, <span style="color:#66d9ef">sizeof</span>(malloc_readonly), PROT_READ);
<span style="color:#ae81ff">1252</span>         _MALLOC_UNLOCK(<span style="color:#ae81ff">1</span>);
<span style="color:#ae81ff">1253</span> }
</code></pre></div><p>from the above code-snippet, we can see that first it does some MALLOC_LOCKing and checks for <code>from_rthreads</code> and <code>mopts.malloc_pool[1]</code> as a result it is not <code>true</code> due to <code>mopts.malloc_pool[1]</code> which is <code>NULL</code>.
Then, after that it checks for <code>mopts.malloc_canary</code> and for the first time it will be 0 due to the structure initialized to zero (0) and then it calls function <code>omalloc_init()</code> and the defination as given below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">405</span>	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>
<span style="color:#ae81ff">406</span>	<span style="color:#a6e22e">omalloc_init</span>(<span style="color:#66d9ef">void</span>)
<span style="color:#ae81ff">407</span>	{
<span style="color:#ae81ff">408</span>		<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>p, <span style="color:#f92672">*</span>q, b[<span style="color:#ae81ff">16</span>];
<span style="color:#ae81ff">409</span>		<span style="color:#66d9ef">int</span> i, j, mib[<span style="color:#ae81ff">2</span>];
<span style="color:#ae81ff">410</span>		size_t sb;
<span style="color:#ae81ff">411</span>
<span style="color:#ae81ff">412</span>		<span style="color:#75715e">/*
</span><span style="color:#75715e">413		 * Default options
</span><span style="color:#75715e">414		 */</span>
<span style="color:#ae81ff">415</span>		mopts.malloc_mutexes <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>;
<span style="color:#ae81ff">416</span>		mopts.def_malloc_junk <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#ae81ff">417</span>		mopts.def_malloc_cache <span style="color:#f92672">=</span> MALLOC_DEFAULT_CACHE;
<span style="color:#ae81ff">418</span>
<span style="color:#ae81ff">419</span>		<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>; i<span style="color:#f92672">++</span>) {
<span style="color:#ae81ff">420</span>			<span style="color:#66d9ef">switch</span> (i) {
<span style="color:#ae81ff">421</span>			<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">422</span>				mib[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> CTL_VM;
<span style="color:#ae81ff">423</span>				mib[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> VM_MALLOC_CONF;
<span style="color:#ae81ff">424</span>				sb <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(b);
<span style="color:#ae81ff">425</span>				j <span style="color:#f92672">=</span> sysctl(mib, <span style="color:#ae81ff">2</span>, b, <span style="color:#f92672">&amp;</span>sb, NULL, <span style="color:#ae81ff">0</span>);
<span style="color:#ae81ff">426</span>				<span style="color:#66d9ef">if</span> (j <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
<span style="color:#ae81ff">427</span>					<span style="color:#66d9ef">continue</span>;
<span style="color:#ae81ff">428</span>				p <span style="color:#f92672">=</span> b;
<span style="color:#ae81ff">429</span>				<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">430</span>			<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">431</span>				<span style="color:#66d9ef">if</span> (issetugid() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
<span style="color:#ae81ff">432</span>					p <span style="color:#f92672">=</span> getenv(<span style="color:#e6db74">&#34;MALLOC_OPTIONS&#34;</span>);
<span style="color:#ae81ff">433</span>				<span style="color:#66d9ef">else</span>
<span style="color:#ae81ff">434</span>					<span style="color:#66d9ef">continue</span>;
<span style="color:#ae81ff">435</span>				<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">436</span>			<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">437</span>				p <span style="color:#f92672">=</span> malloc_options;
<span style="color:#ae81ff">438</span>				<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">439</span>			<span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">440</span>				p <span style="color:#f92672">=</span> NULL;
<span style="color:#ae81ff">441</span>			}
<span style="color:#ae81ff">442</span>
<span style="color:#ae81ff">443</span>			<span style="color:#66d9ef">for</span> (; p <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;\0&#39;</span>; p<span style="color:#f92672">++</span>) {
<span style="color:#ae81ff">444</span>				<span style="color:#66d9ef">switch</span> (<span style="color:#f92672">*</span>p) {
<span style="color:#ae81ff">445</span>				<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;S&#39;</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">446</span>					<span style="color:#66d9ef">for</span> (q <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;CFGJ&#34;</span>; <span style="color:#f92672">*</span>q <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;\0&#39;</span>; q<span style="color:#f92672">++</span>)
<span style="color:#ae81ff">447</span>						omalloc_parseopt(<span style="color:#f92672">*</span>q);
<span style="color:#ae81ff">448</span>					mopts.def_malloc_cache <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#ae81ff">449</span>					<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">450</span>				<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;s&#39;</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">451</span>					<span style="color:#66d9ef">for</span> (q <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;cfgj&#34;</span>; <span style="color:#f92672">*</span>q <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;\0&#39;</span>; q<span style="color:#f92672">++</span>)
<span style="color:#ae81ff">452</span>						omalloc_parseopt(<span style="color:#f92672">*</span>q);
<span style="color:#ae81ff">453</span>					mopts.def_malloc_cache <span style="color:#f92672">=</span> MALLOC_DEFAULT_CACHE;
<span style="color:#ae81ff">454</span>					<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">455</span>				<span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">456</span>					omalloc_parseopt(<span style="color:#f92672">*</span>p);
<span style="color:#ae81ff">457</span>					<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">458</span>				}
<span style="color:#ae81ff">459</span>			}
<span style="color:#ae81ff">460</span>		}
<span style="color:#ae81ff">461</span>
<span style="color:#ae81ff">462</span>	<span style="color:#960050;background-color:#1e0010">#</span>ifdef MALLOC_STATS
<span style="color:#ae81ff">463</span>		<span style="color:#66d9ef">if</span> (mopts.malloc_stats <span style="color:#f92672">&amp;&amp;</span> (atexit(malloc_exit) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)) {
<span style="color:#ae81ff">464</span>			dprintf(STDERR_FILENO, <span style="color:#e6db74">&#34;malloc() warning: atexit(2) failed.&#34;</span>
<span style="color:#ae81ff">465</span>			    <span style="color:#e6db74">&#34; Will not be able to dump stats on exit</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
<span style="color:#ae81ff">466</span>		}
<span style="color:#ae81ff">467</span>	<span style="color:#960050;background-color:#1e0010">#</span>endif <span style="color:#75715e">/* MALLOC_STATS */</span>
<span style="color:#ae81ff">468</span>
<span style="color:#ae81ff">469</span>		<span style="color:#66d9ef">while</span> ((mopts.malloc_canary <span style="color:#f92672">=</span> arc4random()) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
<span style="color:#ae81ff">470</span>			;
<span style="color:#ae81ff">471</span>	}
</code></pre></div><p>OpenBSD <a href="https://man.openbsd.org/malloc.3">malloc(3)</a> has lots of security features and they are configurable using three options:</p>
<ul>
<li><code>systcl(8)</code></li>
<li>environment variable <code>MALLOC_OPTIONS</code></li>
<li>compile-time option <code>malloc_options</code></li>
</ul>
<p>Suppose, for better security we would like to use the canaries, so that can be enabled by setting the option using systcl(8), for example: <code>systcl vm.malloc_conf=C</code></p>
<p><code>omalloc_init()</code> code workings:</p>
<ul>
<li>Initializes some variables of <code>malloc_readonly</code> structure to default values like <code>mopts.malloc_mutexes</code> is the default number of mutexes, <code>mopts.def_malloc_junk</code> is the default number of junk filling and <code>mopts.def_malloc_cache</code> is the default number of free page cache</li>
<li>Then, it checks the option which we have used to configure malloc and we have used sysctl(8). So, for sysctl it goes to <code>case 0:</code> and get the value to <code>char b[16]</code> and then it assigns to pointer to character variable <code>p</code> then after looping for other two it goes for extracting the value that is there in <code>p</code></li>
<li>further, it checks for the malloc option <code>S</code> which enables all the security auditing features of OpenBSD <a href="https://man.openbsd.org/malloc.3">malloc(3)</a>
<ul>
<li>If it is there then it calls <code>omalloc_parseopt(*q);</code> function then after that it sets <code>mopts.def_malloc_cache</code> to <code>0</code> or to <code>MALLOC_DEFAULT_CACHE</code>, depends on whether it is <code>S</code> or <code>s</code></li>
<li>If it is not there, then it simply calls the function <code>omalloc_parseopt(*p);</code></li>
</ul>
</li>
</ul>
<p><code>omalloc_parseopt(char opt)</code> is responsible for extracting the character and in our case it is <code>C</code> for malloc canaries, after parsing it goes to <code>case 'C'</code> and sets <code>mopts.chunk_canaries</code> to <code>1</code>, it does the same for other options and set or enables (initializes) their variables.
Defination of <code>omalloc_parseopt(char opt)</code> as mentioned:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">322</span>	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>
<span style="color:#ae81ff">323</span>	<span style="color:#a6e22e">omalloc_parseopt</span>(<span style="color:#66d9ef">char</span> opt)
<span style="color:#ae81ff">324</span>	{
<span style="color:#ae81ff">325</span>		<span style="color:#66d9ef">switch</span> (opt) {
<span style="color:#ae81ff">326</span>		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;+&#39;</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">327</span>			mopts.malloc_mutexes <span style="color:#f92672">&lt;&lt;=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#ae81ff">328</span>			<span style="color:#66d9ef">if</span> (mopts.malloc_mutexes <span style="color:#f92672">&gt;</span> _MALLOC_MUTEXES)
<span style="color:#ae81ff">329</span>				mopts.malloc_mutexes <span style="color:#f92672">=</span> _MALLOC_MUTEXES;
<span style="color:#ae81ff">330</span>			<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">331</span>		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;-&#39;</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">332</span>			mopts.malloc_mutexes <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#ae81ff">333</span>			<span style="color:#66d9ef">if</span> (mopts.malloc_mutexes <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>)
<span style="color:#ae81ff">334</span>				mopts.malloc_mutexes <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
<span style="color:#ae81ff">335</span>			<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">336</span>		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;&gt;&#39;</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">337</span>			mopts.def_malloc_cache <span style="color:#f92672">&lt;&lt;=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#ae81ff">338</span>			<span style="color:#66d9ef">if</span> (mopts.def_malloc_cache <span style="color:#f92672">&gt;</span> MALLOC_MAXCACHE)
<span style="color:#ae81ff">339</span>				mopts.def_malloc_cache <span style="color:#f92672">=</span> MALLOC_MAXCACHE;
<span style="color:#ae81ff">340</span>			<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">341</span>		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;&lt;&#39;</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">342</span>			mopts.def_malloc_cache <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#ae81ff">343</span>			<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">344</span>		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;c&#39;</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">345</span>			mopts.chunk_canaries <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#ae81ff">346</span>			<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">347</span>		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;C&#39;</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">348</span>			mopts.chunk_canaries <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#ae81ff">349</span>			<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">350</span>	<span style="color:#960050;background-color:#1e0010">#</span>ifdef MALLOC_STATS
<span style="color:#ae81ff">351</span>		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;d&#39;</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">352</span>			mopts.malloc_stats <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#ae81ff">353</span>			<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">354</span>		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;D&#39;</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">355</span>			mopts.malloc_stats <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#ae81ff">356</span>			<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">357</span>	<span style="color:#960050;background-color:#1e0010">#</span>endif <span style="color:#75715e">/* MALLOC_STATS */</span>
<span style="color:#ae81ff">358</span>		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;f&#39;</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">359</span>			mopts.malloc_freecheck <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#ae81ff">360</span>			mopts.malloc_freeunmap <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#ae81ff">361</span>			<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">362</span>		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;F&#39;</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">363</span>			mopts.malloc_freecheck <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#ae81ff">364</span>			mopts.malloc_freeunmap <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#ae81ff">365</span>			<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">366</span>		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;g&#39;</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">367</span>			mopts.malloc_guard <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#ae81ff">368</span>			<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">369</span>		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;G&#39;</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">370</span>			mopts.malloc_guard <span style="color:#f92672">=</span> MALLOC_PAGESIZE;
<span style="color:#ae81ff">371</span>			<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">372</span>		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;j&#39;</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">373</span>			<span style="color:#66d9ef">if</span> (mopts.def_malloc_junk <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
<span style="color:#ae81ff">374</span>				mopts.def_malloc_junk<span style="color:#f92672">--</span>;
<span style="color:#ae81ff">375</span>			<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">376</span>		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;J&#39;</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">377</span>			<span style="color:#66d9ef">if</span> (mopts.def_malloc_junk <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>)
<span style="color:#ae81ff">378</span>				mopts.def_malloc_junk<span style="color:#f92672">++</span>;
<span style="color:#ae81ff">379</span>			<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">380</span>		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;r&#39;</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">381</span>			mopts.malloc_realloc <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#ae81ff">382</span>			<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">383</span>		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;R&#39;</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">384</span>			mopts.malloc_realloc <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#ae81ff">385</span>			<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">386</span>		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;u&#39;</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">387</span>			mopts.malloc_freeunmap <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#ae81ff">388</span>			<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">389</span>		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;U&#39;</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">390</span>			mopts.malloc_freeunmap <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#ae81ff">391</span>			<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">392</span>		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;x&#39;</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">393</span>			mopts.malloc_xmalloc <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#ae81ff">394</span>			<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">395</span>		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;X&#39;</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">396</span>			mopts.malloc_xmalloc <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#ae81ff">397</span>			<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">398</span>		<span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
<span style="color:#ae81ff">399</span>			dprintf(STDERR_FILENO, <span style="color:#e6db74">&#34;malloc() warning: &#34;</span>
<span style="color:#ae81ff">400</span>	                    <span style="color:#e6db74">&#34;unknown char in MALLOC_OPTIONS</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
<span style="color:#ae81ff">401</span>			<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">402</span>		}
<span style="color:#ae81ff">403</span>	}
</code></pre></div><p>As we can see that there are some <code>MALLOC_STATS</code> in the entire source, which means it dumps extra malloc stats information. So, coming back to <code>omalloc_init()</code>, after completing <code>omalloc_parseopt(char opt)</code> function, there are some malloc stats condition then, a random cookie gets assign to <code>mopts.malloc_canary</code> using <code>arc4random()</code></p>
<p>Coming back to defination of <code>_malloc_init(0)</code>, after the completion of <code>omalloc_init()</code>,  there is a variable named <code>nmutexes</code> which gets assign bydefault to <code>2</code> for single-threaded programs, we have already seen the initalization of <code>mopts.malloc_mutexes</code> default to <code>8</code> for multi-threaded programs in the function <code>omalloc_init()</code>. For single-threaded, the value of variable <code>from_rthread</code> is <code>0</code>
Then, it checks for <code>MALLOC_PAGEMASK</code> bit for <code>malloc_readonly</code> address or simply we can say that it is checking the last 12 bits of the <code>malloc_readonly</code> structure address and all 12 bits must be <code>0</code> to apply the perm bit <code>PROT_READ</code> and <code>PROT_WRITE</code>. Could say from the debugger that it is also checking for even address</p>
<p>After that, there is a loop till the <code>nmutexes</code> which is 2 for our single-threaded case.</p>
<ul>
<li>For single-threaded programs, it maintains two malloc <code>dir_info</code> pools as indicates from the variable <code>nmutexes</code>. One for <code>MAP_CONCEALED</code> memory and one for regular</li>
<li>For multi-threaded porgram more pools are created. This is to avoid contention, accesses to diffrent pools can run concurently.</li>
</ul>
<blockquote>
<p>reference:<br>
<a href="https://marc.info/?l=openbsd-tech&amp;m=154521318606876&amp;w=2">related to multi-pools - mailing list</a><br>
<a href="https://github.com/libressl-portable/openbsd/commit/55874ab3542715ce7e5c5e8ec0d6e1d7576a29a6#diff-5ce2636352a42c4e4a687c72939dbec9">github diff for more pools</a>]</p>
</blockquote>
<p><code>if i == 0</code> responsible for MAP_CONCEALED memory through call <code>omalloc_poolinit(&amp;d, MAP_CONCEAL);</code> and <code>else</code> responsible for <code>omalloc_poolinit(&amp;d, 0);</code> regular memory pools.</p>
<p>Defination of <code>omalloc_poolinit()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">473</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>
<span style="color:#ae81ff">474</span> <span style="color:#a6e22e">omalloc_poolinit</span>(<span style="color:#66d9ef">struct</span> dir_info <span style="color:#f92672">**</span>dp, <span style="color:#66d9ef">int</span> mmap_flag)
<span style="color:#ae81ff">475</span> {
<span style="color:#ae81ff">476</span>         <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>p;
<span style="color:#ae81ff">477</span>         size_t d_avail, regioninfo_size;
<span style="color:#ae81ff">478</span>         <span style="color:#66d9ef">struct</span> dir_info <span style="color:#f92672">*</span>d;
<span style="color:#ae81ff">479</span>         <span style="color:#66d9ef">int</span> i, j;
<span style="color:#ae81ff">480</span>
<span style="color:#ae81ff">481</span>         <span style="color:#75715e">/*
</span><span style="color:#75715e">482          * Allocate dir_info with a guard page on either side. Also
</span><span style="color:#75715e">483          * randomise offset inside the page at which the dir_info
</span><span style="color:#75715e">484          * lies (subject to alignment by 1 &lt;&lt; MALLOC_MINSHIFT)
</span><span style="color:#75715e">485          */</span>
<span style="color:#ae81ff">486</span>         <span style="color:#66d9ef">if</span> ((p <span style="color:#f92672">=</span> MMAPNONE(DIR_INFO_RSZ <span style="color:#f92672">+</span> (MALLOC_PAGESIZE <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>), mmap_flag)) <span style="color:#f92672">==</span>
<span style="color:#ae81ff">487</span>             MAP_FAILED)
<span style="color:#ae81ff">488</span>                 wrterror(NULL, <span style="color:#e6db74">&#34;malloc init mmap failed&#34;</span>);
<span style="color:#ae81ff">489</span>         mprotect(p <span style="color:#f92672">+</span> MALLOC_PAGESIZE, DIR_INFO_RSZ, PROT_READ <span style="color:#f92672">|</span> PROT_WRITE);
<span style="color:#ae81ff">490</span>         d_avail <span style="color:#f92672">=</span> (DIR_INFO_RSZ <span style="color:#f92672">-</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>d)) <span style="color:#f92672">&gt;&gt;</span> MALLOC_MINSHIFT;
<span style="color:#ae81ff">491</span>         d <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> dir_info <span style="color:#f92672">*</span>)(p <span style="color:#f92672">+</span> MALLOC_PAGESIZE <span style="color:#f92672">+</span>
<span style="color:#ae81ff">492</span>             (arc4random_uniform(d_avail) <span style="color:#f92672">&lt;&lt;</span> MALLOC_MINSHIFT));
<span style="color:#ae81ff">493</span>
<span style="color:#ae81ff">494</span>         rbytes_init(d);
<span style="color:#ae81ff">495</span>         d<span style="color:#f92672">-&gt;</span>regions_free <span style="color:#f92672">=</span> d<span style="color:#f92672">-&gt;</span>regions_total <span style="color:#f92672">=</span> MALLOC_INITIAL_REGIONS;
<span style="color:#ae81ff">496</span>         regioninfo_size <span style="color:#f92672">=</span> d<span style="color:#f92672">-&gt;</span>regions_total <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> region_info);
<span style="color:#ae81ff">497</span>         d<span style="color:#f92672">-&gt;</span>r <span style="color:#f92672">=</span> MMAP(regioninfo_size, mmap_flag);
<span style="color:#ae81ff">498</span>         <span style="color:#66d9ef">if</span> (d<span style="color:#f92672">-&gt;</span>r <span style="color:#f92672">==</span> MAP_FAILED) {
<span style="color:#ae81ff">499</span>                 d<span style="color:#f92672">-&gt;</span>regions_total <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#ae81ff">500</span>                 wrterror(NULL, <span style="color:#e6db74">&#34;malloc init mmap failed&#34;</span>);
<span style="color:#ae81ff">501</span>         }
<span style="color:#ae81ff">502</span>         <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> MALLOC_MAXSHIFT; i<span style="color:#f92672">++</span>) {
<span style="color:#ae81ff">503</span>                 LIST_INIT(<span style="color:#f92672">&amp;</span>d<span style="color:#f92672">-&gt;</span>chunk_info_list[i]);
<span style="color:#ae81ff">504</span>                 <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> MALLOC_CHUNK_LISTS; j<span style="color:#f92672">++</span>)
<span style="color:#ae81ff">505</span>                         LIST_INIT(<span style="color:#f92672">&amp;</span>d<span style="color:#f92672">-&gt;</span>chunk_dir[i][j]);
<span style="color:#ae81ff">506</span>         }
<span style="color:#ae81ff">507</span>         STATS_ADD(d<span style="color:#f92672">-&gt;</span>malloc_used, regioninfo_size <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> MALLOC_PAGESIZE);
<span style="color:#ae81ff">508</span>         d<span style="color:#f92672">-&gt;</span>mmap_flag <span style="color:#f92672">=</span> mmap_flag;
<span style="color:#ae81ff">509</span>         d<span style="color:#f92672">-&gt;</span>malloc_junk <span style="color:#f92672">=</span> mopts.def_malloc_junk;
<span style="color:#ae81ff">510</span>         d<span style="color:#f92672">-&gt;</span>malloc_cache <span style="color:#f92672">=</span> mopts.def_malloc_cache;
<span style="color:#ae81ff">511</span>         d<span style="color:#f92672">-&gt;</span>canary1 <span style="color:#f92672">=</span> mopts.malloc_canary <span style="color:#f92672">^</span> (u_int32_t)(uintptr_t)d;
<span style="color:#ae81ff">512</span>         d<span style="color:#f92672">-&gt;</span>canary2 <span style="color:#f92672">=</span> <span style="color:#f92672">~</span>d<span style="color:#f92672">-&gt;</span>canary1;
<span style="color:#ae81ff">513</span>
<span style="color:#ae81ff">514</span>         <span style="color:#f92672">*</span>dp <span style="color:#f92672">=</span> d;
<span style="color:#ae81ff">515</span> }
</code></pre></div><p><code>omalloc_poolinit(struct dir_info **dp, int mmap_flag)</code> workings:</p>
<ul>
<li>After some basic variable declarations, first it maps page into memory using mmap(2) in MMAPNONE(sz, f) where sz is the size and f is the flag</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">96</span> <span style="color:#960050;background-color:#1e0010">#</span>define MMAPNONE(sz,f)  mmap(NULL, (sz), PROT_NONE, \
<span style="color:#ae81ff">97</span>     MAP_ANON <span style="color:#f92672">|</span> MAP_PRIVATE <span style="color:#f92672">|</span> (f), <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>)
</code></pre></div><ul>
<li>So, as from the above macro defination, we can see that the first parameter of mmap(2), that is, addr is <code>NULL</code> and as per the <a href="https://man.openbsd.org/mmap.2">mmap(2)</a> man page</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">The mmap() function causes the contents of fd, starting at offset, to be
mapped in memory at the given addr.  The mapping will extend at least len
bytes, subject to page alignment restrictions.

The addr argument describes the address where the system should place the
mapping.  If the MAP_FIXED flag is specified, the allocation will happen
at the specified address, replacing any previously established mappings
in its range.  Otherwise, the mapping will be placed at the available
spot at addr; failing that it will be placed &#34;close by&#34;.
```
If addr is NULL the system can pick any address. Except for MAP_FIXED mappings, the
system will never replace existing mappings.
```
The len argument describes the minimum amount of bytes the mapping will
span.  Since mmap() maps pages into memory, len may be rounded up to hit
a page boundary.  If len is 0, the mapping will fail with EINVAL.
</code></pre></div><ul>
<li>Following are the page mapping calculations based on debugging</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">sz = DIR_INFO_RSZ + (MALLOC_PAGESIZE * 2)
where DIR_INFO_RSZ = ((sizeof(struct dir_info) + MALLOC_PAGEMASK) &amp; ~MALLOC_PAGEMASK)
MALLOC_PAGEMASK = 4095 bytes
MALLOC_PAGESIZE = 4096 bytes
So, DIR_INFO_RSZ becomes (4284 + 4095) &amp; ~4095 = 8192 bytes
and sz becomes 8192 + (4096 * 2) = 16384 bytes
and, f = MMAP_CONCEAL; which means it prevents from leaking the information and also it excludes the mapping from core dumps
</code></pre></div><ul>
<li>So in above page mapping calculation, <code>DIR_INFO_RSZ</code> indicates that to store the <code>dir_info</code> structure we need <code>2 pages</code> and allocate <code>4 pages</code> PROT_NONE using MMAPNONE with flag as &ldquo;MAP_CONCEAL&rdquo;, which we can see from the <code>omalloc_poolinit():L486</code></li>
<li>Then, making two middle pages R/W which can be seen from the macro value of DIR_INFO_RSZ, 2 pages</li>
<li>then, calculate the <strong><em>d_avail</em></strong> to randomise offset inside the page at which the <strong><em>dir_info</em></strong> present (subject to alignment by 1 &laquo; MALLOC_MINSHIFT)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">    d_avail = (8192 - 4824) &gt;&gt; 4 = 3368 &gt;&gt; 4 = 210
</code></pre></div><ul>
<li>the d_avail is 210, now calculate offset, d</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">    d = (struct dir_info *)(p + MALLOC_PAGESIZE + (arc4random_uniform(d_avail) &lt;&lt; MALLOC_MINSHIFT));
</code></pre></div><ul>
<li>So, as mentioned by the developer <strong><em><a href="https://twitter.com/ottom6k">Otto@</a></em></strong> in the <a href="https://marc.info/?l=openbsd-tech&amp;m=158408023212237&amp;w=2">mailing list</a> that the <strong>dir_info</strong> structure ends up on an aligned address somewhere in the middle pages on an offset between 0 and (210&laquo;4) which further resolves in between 0 to 3360, counting from the start of the two middle pages. So, it becomes like <code>d = [p + MALLOC_PAGESIZE + (0..3360)]</code>, where (0..3360) is the offset value from 0 to 3360 max</li>
<li>from my understanding, it looks like there is no guard page bydefault enabled on the both the sides, however, it is there for only one side but after confirming the understanding with the developer <strong><em><a href="https://twitter.com/ottom6k">Otto@</a></em></strong>, he mentioned that<code>dir_info is special and having a guard page on both sides for regular allocation can be done, but would waste more pages</code> and also mentioned to note that <code>allocations are already spread throughout the address space, so it is very likely that an allocation is surrounded by unmapped pages</code>. So, finally the conclusion is that there will be guard pages on each side as per the malloc design so no need to allocate extra as that will be waste of pages.</li>
<li>Then it initializes random bytes using the <code>rbytes_init(d)</code>.</li>
</ul>
<p>Defination of <code>rbytes_init(struct dir_info *d);</code> as mentioned:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">303</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>
<span style="color:#ae81ff">304</span> <span style="color:#a6e22e">rbytes_init</span>(<span style="color:#66d9ef">struct</span> dir_info <span style="color:#f92672">*</span>d)
<span style="color:#ae81ff">305</span> {
<span style="color:#ae81ff">306</span>         arc4random_buf(d<span style="color:#f92672">-&gt;</span>rbytes, <span style="color:#66d9ef">sizeof</span>(d<span style="color:#f92672">-&gt;</span>rbytes));
<span style="color:#ae81ff">307</span>         <span style="color:#75715e">/* add 1 to account for using d-&gt;rbytes[0] */</span>
<span style="color:#ae81ff">308</span>         d<span style="color:#f92672">-&gt;</span>rbytesused <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> d<span style="color:#f92672">-&gt;</span>rbytes[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">%</span> (<span style="color:#66d9ef">sizeof</span>(d<span style="color:#f92672">-&gt;</span>rbytes) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>);
<span style="color:#ae81ff">309</span> } 
</code></pre></div><ul>
<li><code>rbytes_init()</code> is responsible for filling the <code>d-&gt;rbytes</code> with the random bytes using the <code>arc4random_buf()</code> and keeps track/count of the rbytes used through <code>d-&gt;rbytesused</code></li>
<li>after this, coming back to <code>omalloc_poolinit()</code>, it is initializing the default values for some of the structure members, <code>d-&gt;regions_free = dir-&gt;regions_total = MALLOC_INTIAL_REGIONS;</code> where the value of macro <strong>MALLOC_INITIAL_REGIONS</strong> is <strong>512</strong>. Also, calculates the total region_info size, <code>regioninfo_size = d-&gt;regions_total * sizeof(struct region_info);</code></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">105</span> <span style="color:#66d9ef">struct</span> region_info {
<span style="color:#ae81ff">106</span>         <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>p;                <span style="color:#75715e">/* page; low bits used to mark chunks */</span>
<span style="color:#ae81ff">107</span>         uintptr_t size;         <span style="color:#75715e">/* size for pages, or chunk_info pointer */</span>
<span style="color:#ae81ff">108</span> <span style="color:#960050;background-color:#1e0010">#</span>ifdef MALLOC_STATS
<span style="color:#ae81ff">109</span>         <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>f;                <span style="color:#75715e">/* where allocated from */</span>
<span style="color:#ae81ff">110</span> <span style="color:#960050;background-color:#1e0010">#</span>endif
<span style="color:#ae81ff">111</span> }; 
</code></pre></div><ul>
<li>
<p>The structure <code>struct region_info</code> is used to keep track of mmaped regions by storing their address and size into a hash table as mentioned in the <a href="https://www.openbsd.com.au/papers/eurobsdcon2009/otto-malloc.pdf">slides</a> of <strong><em><a href="https://twitter.com/ottom6k">Otto@</a></em></strong></p>
</li>
<li>
<p>further, it maps pages of size <strong>regioninfo_size</strong> for regions with the flag <strong>MAP_CONCEAL</strong> and assigns it to <code>d-&gt;r</code> and then check if mapping failed</p>
</li>
<li>
<p>While understanding the internals of malloc(3), I did not understand the working of the code-snippet as mentioned:</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">...
...
...
<span style="color:#ae81ff">502</span>         <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> MALLOC_MAXSHIFT; i<span style="color:#f92672">++</span>) {
<span style="color:#ae81ff">503</span>                 LIST_INIT(<span style="color:#f92672">&amp;</span>d<span style="color:#f92672">-&gt;</span>chunk_info_list[i]);
<span style="color:#ae81ff">504</span>                 <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> MALLOC_CHUNK_LISTS; j<span style="color:#f92672">++</span>)
<span style="color:#ae81ff">505</span>                         LIST_INIT(<span style="color:#f92672">&amp;</span>d<span style="color:#f92672">-&gt;</span>chunk_dir[i][j]);
<span style="color:#ae81ff">506</span>         }
...
...
... 
</code></pre></div><ul>
<li><strong>What is the purpose of creating these many linked lists?</strong>
<ul>
<li>after discussing the query with the developer <strong><em><a href="https://twitter.com/ottom6k">Otto@</a></em></strong>, I came to know that these many lists is used to allow more randomization, as per the words by the developer, <strong><em><a href="https://twitter.com/ottom6k">Otto@</a></em></strong> said <code>More than one list of free chunk pages per chunk size is maintained to allow for more randomization.</code></li>
<li>in short, the above nested for loops will create 12 chunk_info_list where i is 0 to 11 and for each and every ith index there is j, so as per that,</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">chunk_info_list[<span style="color:#ae81ff">0</span>]
	chunk_dir[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>]
	chunk_dir[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>]
	chunk_dir[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">2</span>]
	chunk_dir[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">3</span>]
...
...
...
chunk_info_list[<span style="color:#ae81ff">11</span>]
	chunk_dir[<span style="color:#ae81ff">11</span>][<span style="color:#ae81ff">0</span>]
	chunk_dir[<span style="color:#ae81ff">11</span>][<span style="color:#ae81ff">1</span>]
	chunk_dir[<span style="color:#ae81ff">11</span>][<span style="color:#ae81ff">2</span>]
	chunk_dir[<span style="color:#ae81ff">11</span>][<span style="color:#ae81ff">3</span>]

...
...
...
</code></pre></div><ul>
<li>also confirmed with the developer that we can also allow more randomization by increasing the <strong>MALLOC_CHUNK_LISTS</strong> but at the cost of overhead. Increasing the <strong>MALLOC_MAXSHIFT</strong> is not possible because it is the shift of the max chunk size that fits in a page. We will see later how these lists helps to achieve randomization</li>
<li>then, adds and updated the <strong>d-&gt;malloc_used</strong> for dumping the malloc stats information</li>
<li>further, updated the default initialization of variables given below:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">...
...
...
<span style="color:#ae81ff">508</span>         d<span style="color:#f92672">-&gt;</span>mmap_flag <span style="color:#f92672">=</span> mmap_flag;
<span style="color:#ae81ff">509</span>         d<span style="color:#f92672">-&gt;</span>malloc_junk <span style="color:#f92672">=</span> mopts.def_malloc_junk;
<span style="color:#ae81ff">510</span>         d<span style="color:#f92672">-&gt;</span>malloc_cache <span style="color:#f92672">=</span> mopts.def_malloc_cache;
<span style="color:#ae81ff">511</span>         d<span style="color:#f92672">-&gt;</span>canary1 <span style="color:#f92672">=</span> mopts.malloc_canary <span style="color:#f92672">^</span> (u_int32_t)(uintptr_t)d;
<span style="color:#ae81ff">512</span>         d<span style="color:#f92672">-&gt;</span>canary2 <span style="color:#f92672">=</span> <span style="color:#f92672">~</span>d<span style="color:#f92672">-&gt;</span>canary1;
<span style="color:#ae81ff">513</span>
<span style="color:#ae81ff">514</span>         <span style="color:#f92672">*</span>dp <span style="color:#f92672">=</span> d;
<span style="color:#ae81ff">515</span> }
	<span style="color:#75715e">/* where it is already mentioned above code snippets that mopts.def_malloc_junk is 1 and
</span><span style="color:#75715e">	 *  mopts.def_malloc_cache is 64, already initialized default values in omalloc_init() 
</span><span style="color:#75715e">	 */</span> 
</code></pre></div><ul>
<li>
<p>then, <strong>dir_info</strong> uses two canaries. Its calculation is easy to understand. Whatever the address of <code>d ( struct dir_info *d)</code> just typecast it to <code>(u_int32_t)(uintptr_t)</code> and <code>XOR</code> it with <code>mopts.malloc_canary</code> and assign the result to <code>d-&gt;canary1</code> and then compute the <code>not (~)</code> of <code>d-&gt;canary1</code> then assign the result to <code>d-&gt;canary2</code> or in simpler words, convert into binary then take each bit and flips them to their logical opposite. convert 1&rsquo;s to 0&rsquo;s and vice versa then convert it to hex and assign it to <code>d-&gt;canary2</code></p>
</li>
<li>
<p>Finally assign the initialized <code>dir_info</code> structure <code>d</code> to <code>*dp</code></p>
</li>
</ul>
<p>Coming back to <code>_malloc_init(int from_rthreads)</code>, so, as per the defination <code>_malloc_init()</code>, for <code>i == 0</code>, we have completed the function <code>omalloc_poolinit(&amp;d, MAP_CONCEAL);</code>, now further, it assigns <code>d-&gt;malloc_junk = 2;</code> and <code>d-&gt;malloc_cache = 0;</code></p>
<p>Then, it saves the index <code>i</code> to <code>d-&gt;mutex</code> and stored the initialized MAP_CONCEALED pool to <code>mopts.malloc_pool[i] = d;</code></p>
<p>The value of <strong>nmutexes</strong> is 2, so, the loop will execute again and will do the whole same operations for index <code>i == 1</code> (or <code>i != 0</code>). So, again it invokes <code>omalloc_poolinit(&amp;d, 0)</code> but without <code>MAP_CONCEAL</code> flag and this time it is 0. It performs same operation with second argument as 0.</p>
<p>After complete execution of function <code>omalloc_poolinit(&amp;d, 0)</code>, it sets junk value to default junk value and same for malloc_cache, that is, <code>d-&gt;malloc_junk = mopts.def_malloc_junk;</code> and <code>d-&gt;malloc_cache = mopts.def_malloc_cache;</code>. Now, again performes the same operation like for saving the new index <code>1</code> to <code>d-&gt;mutex</code> and stores the pool to <code>mopts.malloc_pool[i] = d</code> if <code>i == 1</code></p>
<p>Now, <strong>mopts.malloc_pool</strong> has two pools,</p>
<ul>
<li><strong>mopts.malloc_pool[0]</strong></li>
<li><strong>mopts.malloc_pool[1]</strong></li>
</ul>
<p>Next, it checks for multi-threading from variable <strong>from_rthreads</strong>, if the value is non-zero then it sets <strong>mopts.malloc_mt = 1</strong> which shows that program is multi-threaded but for our case it is zero (0), so <code>if</code> cond fails and <code>else</code> cond executes and sets <strong>mopts.internal_funcs = 1</strong>, from the structure <code>malloc_readonly</code>, it shows that setting <strong>internal_funcs</strong> means to use better function like recallocarray/freezero but there is no such things occurs for our case, maybe we have to use it for some other scenarios like in case of, calloc, etc. <a href="https://marc.info/?l=openbsd-tech&amp;m=148846616030488&amp;w=2">recallocarray(3) - mailing list</a></p>
<p>Finally, it sets the perms to readonly, to prevent further tampering with them, again it checks last 12 bits and if they are 0 then it sets perms to PROT_READ, and <code>_malloc_init(0)_</code> completed.
Now, coming back to PROGLOGUE macro code as mentioned below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">1256</span> <span style="color:#960050;background-color:#1e0010">#</span>define PROLOGUE(p, fn)                 \
<span style="color:#ae81ff">1257</span>         d <span style="color:#f92672">=</span> (p);                        \
<span style="color:#ae81ff">1258</span>         <span style="color:#a6e22e">if</span> (d <span style="color:#f92672">==</span> NULL) {                \
<span style="color:#ae81ff">1259</span>                 _malloc_init(<span style="color:#ae81ff">0</span>);        \
<span style="color:#ae81ff">1260</span>                 d <span style="color:#f92672">=</span> (p);                \
<span style="color:#ae81ff">1261</span>         }                               \
<span style="color:#ae81ff">1262</span>         <span style="color:#a6e22e">_MALLOC_LOCK</span>(d<span style="color:#f92672">-&gt;</span>mutex);         \
<span style="color:#ae81ff">1263</span>         d<span style="color:#f92672">-&gt;</span>func <span style="color:#f92672">=</span> fn;                   \
<span style="color:#ae81ff">1264</span>         <span style="color:#a6e22e">if</span> (d<span style="color:#f92672">-&gt;</span>active<span style="color:#f92672">++</span>) {              \
<span style="color:#ae81ff">1265</span>                 malloc_recurse(d);      \
<span style="color:#ae81ff">1266</span>                 <span style="color:#66d9ef">return</span> NULL;            \
<span style="color:#ae81ff">1267</span>         }                               \
</code></pre></div><p>So, we have completed the <code>_malloc_init(0)_</code> function. Remember, p refers to the function <code>getpool()</code>, which gets called in lineno. 1260 and due to single-threaded program, it returns <strong>mopts.malloc_pool[1]</strong>, which has the regular pool, not MAP_CONCEALED one, that, further returns to <strong>d</strong> then malloc_lock and assigns fn to <code>d-&gt;fn</code>, here fn means func string &ldquo;malloc&rdquo;. It checks and incremented the <strong>d-&gt;active</strong> and doesn&rsquo;t go inside the if code-flow due to 0 value of <strong>d-&gt;active</strong></p>
<p><code>malloc(size)</code> code from libc:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">1277</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>
<span style="color:#ae81ff">1278</span> <span style="color:#a6e22e">malloc</span>(size_t size)
<span style="color:#ae81ff">1279</span> {
<span style="color:#ae81ff">1280</span>         <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>r;
<span style="color:#ae81ff">1281</span>         <span style="color:#66d9ef">struct</span> dir_info <span style="color:#f92672">*</span>d;
<span style="color:#ae81ff">1282</span>         <span style="color:#66d9ef">int</span> saved_errno <span style="color:#f92672">=</span> errno;
<span style="color:#ae81ff">1283</span>
<span style="color:#ae81ff">1284</span>         PROLOGUE(getpool(), <span style="color:#e6db74">&#34;malloc&#34;</span>)
<span style="color:#ae81ff">1285</span>         r <span style="color:#f92672">=</span> omalloc(d, size, <span style="color:#ae81ff">0</span>, CALLER);
<span style="color:#ae81ff">1286</span>         EPILOGUE()
<span style="color:#ae81ff">1287</span>         <span style="color:#66d9ef">return</span> r;
<span style="color:#ae81ff">1288</span> }
</code></pre></div><p>From line no. 1285, after PROLOGUE it calls <code>omalloc(d, size, CALLER)</code>.
Defination of <code>omalloc(d, size, CALLER)</code> as mentioned:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">1126</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>
<span style="color:#ae81ff">1127</span> <span style="color:#a6e22e">omalloc</span>(<span style="color:#66d9ef">struct</span> dir_info <span style="color:#f92672">*</span>pool, size_t sz, <span style="color:#66d9ef">int</span> zero_fill, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>f)
<span style="color:#ae81ff">1128</span> {
<span style="color:#ae81ff">1129</span> 	<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>p;
<span style="color:#ae81ff">1130</span> 	size_t psz;
<span style="color:#ae81ff">1131</span>
<span style="color:#ae81ff">1132</span>	<span style="color:#66d9ef">if</span> (sz <span style="color:#f92672">&gt;</span> MALLOC_MAXCHUNK) {
<span style="color:#ae81ff">1133</span>		<span style="color:#66d9ef">if</span> (sz <span style="color:#f92672">&gt;=</span> SIZE_MAX <span style="color:#f92672">-</span> mopts.malloc_guard <span style="color:#f92672">-</span> MALLOC_PAGESIZE) {
<span style="color:#ae81ff">1134</span>			errno <span style="color:#f92672">=</span> ENOMEM;
<span style="color:#ae81ff">1135</span>			<span style="color:#66d9ef">return</span> NULL;
<span style="color:#ae81ff">1136</span>		}
<span style="color:#ae81ff">1137</span>		sz <span style="color:#f92672">+=</span> mopts.malloc_guard;
<span style="color:#ae81ff">1138</span>		psz <span style="color:#f92672">=</span> PAGEROUND(sz);
<span style="color:#ae81ff">1139</span>		p <span style="color:#f92672">=</span> map(pool, NULL, psz, zero_fill);
<span style="color:#ae81ff">1140</span>		<span style="color:#66d9ef">if</span> (p <span style="color:#f92672">==</span> MAP_FAILED) {
<span style="color:#ae81ff">1141</span>			errno <span style="color:#f92672">=</span> ENOMEM;
<span style="color:#ae81ff">1142</span>			<span style="color:#66d9ef">return</span> NULL;
<span style="color:#ae81ff">1143</span>		}
<span style="color:#ae81ff">1144</span>		<span style="color:#66d9ef">if</span> (insert(pool, p, sz, f)) {
<span style="color:#ae81ff">1145</span>			unmap(pool, p, psz, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);
<span style="color:#ae81ff">1146</span>			errno <span style="color:#f92672">=</span> ENOMEM;
<span style="color:#ae81ff">1147</span>			<span style="color:#66d9ef">return</span> NULL;
<span style="color:#ae81ff">1148</span>		}
<span style="color:#ae81ff">1149</span>		<span style="color:#66d9ef">if</span> (mopts.malloc_guard) {
<span style="color:#ae81ff">1150</span>			<span style="color:#66d9ef">if</span> (mprotect((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)p <span style="color:#f92672">+</span> psz <span style="color:#f92672">-</span> mopts.malloc_guard,
<span style="color:#ae81ff">1151</span>			    mopts.malloc_guard, PROT_NONE))
<span style="color:#ae81ff">1152</span>				wrterror(pool, <span style="color:#e6db74">&#34;mprotect&#34;</span>);
<span style="color:#ae81ff">1153</span>			STATS_ADD(pool<span style="color:#f92672">-&gt;</span>malloc_guarded, mopts.malloc_guard);
<span style="color:#ae81ff">1154</span>		}
<span style="color:#ae81ff">1155</span>
<span style="color:#ae81ff">1156</span>    	<span style="color:#66d9ef">if</span> (MALLOC_MOVE_COND(sz)) {
<span style="color:#ae81ff">1157</span>    		<span style="color:#75715e">/* fill whole allocation */</span>
<span style="color:#ae81ff">1158</span>    		<span style="color:#66d9ef">if</span> (pool<span style="color:#f92672">-&gt;</span>malloc_junk <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>)
<span style="color:#ae81ff">1159</span>    			memset(p, SOME_JUNK, psz <span style="color:#f92672">-</span> mopts.malloc_guard);
<span style="color:#ae81ff">1160</span>    		<span style="color:#75715e">/* shift towards the end */</span>
<span style="color:#ae81ff">1161</span>    		p <span style="color:#f92672">=</span> MALLOC_MOVE(p, sz);
<span style="color:#ae81ff">1162</span>    		<span style="color:#75715e">/* fill zeros if needed and overwritten above */</span>
<span style="color:#ae81ff">1163</span>    		<span style="color:#66d9ef">if</span> (zero_fill <span style="color:#f92672">&amp;&amp;</span> pool<span style="color:#f92672">-&gt;</span>malloc_junk <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>)
<span style="color:#ae81ff">1164</span>    			memset(p, <span style="color:#ae81ff">0</span>, sz <span style="color:#f92672">-</span> mopts.malloc_guard);
<span style="color:#ae81ff">1165</span>    	} <span style="color:#66d9ef">else</span> {
<span style="color:#ae81ff">1166</span>    		<span style="color:#66d9ef">if</span> (pool<span style="color:#f92672">-&gt;</span>malloc_junk <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>) {
<span style="color:#ae81ff">1167</span>    			<span style="color:#66d9ef">if</span> (zero_fill)
<span style="color:#ae81ff">1168</span>    				memset((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)p <span style="color:#f92672">+</span> sz <span style="color:#f92672">-</span> mopts.malloc_guard,
<span style="color:#ae81ff">1169</span>    				    SOME_JUNK, psz <span style="color:#f92672">-</span> sz);
<span style="color:#ae81ff">1170</span>    			<span style="color:#66d9ef">else</span>
<span style="color:#ae81ff">1171</span>    				memset(p, SOME_JUNK,
<span style="color:#ae81ff">1172</span>    				    psz <span style="color:#f92672">-</span> mopts.malloc_guard);
<span style="color:#ae81ff">1173</span>    		} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (mopts.chunk_canaries)
<span style="color:#ae81ff">1174</span>    			fill_canary(p, sz <span style="color:#f92672">-</span> mopts.malloc_guard,
<span style="color:#ae81ff">1175</span>    			    psz <span style="color:#f92672">-</span> mopts.malloc_guard);
<span style="color:#ae81ff">1176</span>    	}
<span style="color:#ae81ff">1177</span>
<span style="color:#ae81ff">1178</span>	} <span style="color:#66d9ef">else</span> {
<span style="color:#ae81ff">1179</span>		<span style="color:#75715e">/* takes care of SOME_JUNK */</span>
<span style="color:#ae81ff">1180</span>		p <span style="color:#f92672">=</span> malloc_bytes(pool, sz, f);
<span style="color:#ae81ff">1181</span>		<span style="color:#66d9ef">if</span> (zero_fill <span style="color:#f92672">&amp;&amp;</span> p <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> sz <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
<span style="color:#ae81ff">1182</span>			memset(p, <span style="color:#ae81ff">0</span>, sz);
<span style="color:#ae81ff">1183</span>	}
<span style="color:#ae81ff">1184</span>
<span style="color:#ae81ff">1185</span> 	<span style="color:#66d9ef">return</span> p;
<span style="color:#ae81ff">1186</span> }
</code></pre></div><p><code>omalloc(struct dir_info *pool, size_t sz, int zero_fill, void *f);</code> function internals:</p>
<ul>
<li>There are two code flows
<ul>
<li><code>if ( sz &gt; MALLOC_MAXCHUNK)</code>. Our size is <strong>8</strong> as mentioned in the sample code, so this condition will not be true but still we are going to divein a little. First, it checks if the size is greater than the <strong>MALLOC_MAXCHUNK</strong>, which is 2048</li>
<li>If size is less, then it uses <strong>2nd</strong> code flow which is <code>else</code> condition, that is, it calls <code>malloc_bytes(pool, sz, f);</code> which we will see further, for now we are going to explore the case when the size is greater:
<ul>
<li>After checking the size with <strong>MALLOC_MAXCHUNK</strong>, it further checks if the requested size is greater than SIZE_MAX (excluding mopts.malloc_guard and MALLOC_PAGESIZE) and if yes, then it sets errno to ENOMEM and returns <strong>NULL</strong></li>
</ul>
</li>
<li>then if size is less, it adds the malloc_guard value to requested size and it roundsup the page to multiple of pagesize, for example: if requested size is &lt;= 4096 then it rounds it to 4096 but if requested size is 4097 then it roundsup to 8192</li>
<li>further, it maps the page to size psz with hint address is equals to NULL then check if it fails</li>
<li>next, it calls <code>insert(pool, p, sz, f);</code> function to keep track of mmaped regions by storing their address and size into a hash table, we will dive more in-depth later, if it fails to insert then it unmaps the page and return ENOMEM</li>
<li>it checks for malloc_guard page option, if it sets then it adds a guarded page as per the size mentioned by malloc_guard variable with PROT_NONE perms bit and then it adds the information for stats</li>
<li>then, it checks for <strong>MALLOC_MOVE_COND</strong>, if the condition is true then it shifts the allocations towards the end, as mentioned in the source code comment,</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">70</span> <span style="color:#75715e">/*
</span><span style="color:#75715e">71  * We move allocations between half a page and a whole page towards the end,
</span><span style="color:#75715e">72  * subject to alignment constraints. This is the extra headroom we allow.
</span><span style="color:#75715e">73  * Set to zero to be the most strict.
</span><span style="color:#75715e">74  */</span>
<span style="color:#ae81ff">75</span> <span style="color:#960050;background-color:#1e0010">#</span>define MALLOC_LEEWAY           <span style="color:#ae81ff">0</span>
<span style="color:#ae81ff">76</span> <span style="color:#960050;background-color:#1e0010">#</span>define MALLOC_MOVE_COND(sz)    ((sz) <span style="color:#f92672">-</span> mopts.malloc_guard <span style="color:#f92672">&lt;</span>            \
<span style="color:#ae81ff">77</span>                                     MALLOC_PAGESIZE <span style="color:#f92672">-</span> MALLOC_LEEWAY)
<span style="color:#ae81ff">78</span> <span style="color:#960050;background-color:#1e0010">#</span>define MALLOC_MOVE(p, sz)      (((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)(p)) <span style="color:#f92672">+</span>                        \
<span style="color:#ae81ff">79</span>                                     ((MALLOC_PAGESIZE <span style="color:#f92672">-</span> MALLOC_LEEWAY <span style="color:#f92672">-</span> \
<span style="color:#ae81ff">80</span>                                     ((sz) <span style="color:#f92672">-</span> mopts.malloc_guard)) <span style="color:#f92672">&amp;</span>      \
<span style="color:#ae81ff">81</span>                                     <span style="color:#f92672">~</span>(MALLOC_MINSIZE <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)))<span style="color:#960050;background-color:#1e0010">`</span> 
</code></pre></div><ul>
<li>After checking for condition, first, it checks for junk value, that is,<code>pool-&gt;malloc_junk == 2</code> if it equals <strong>then</strong> it fills the mmap&rsquo;ed page <strong>p</strong> with <strong>SOME_JUNK</strong> which has byte <strong>0xdb</strong>, then as previously mentioned it shifts the allocation towards end with macro <strong>MALLOC_MOVE(p, sz)</strong>, later it checks, if zero-filling requires, if yes then it fills the same JUNKed filled page with zeroes</li>
<li>if the <strong>MALLOC_MOVE_COND</strong> condition is not true then it checks for junk value, that is, <code>pool-&gt;malloc_junk == 2</code>, if it equals to <strong>2</strong> then it checks for zero filling and if it requires then it fills from the address as mentioned in the code snippet and if zero filling not requires then it simply fills with SOME_JUNK as mentioned</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">...
...
...
<span style="color:#ae81ff">1166</span>				<span style="color:#66d9ef">if</span> (pool<span style="color:#f92672">-&gt;</span>malloc_junk <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>) {
<span style="color:#ae81ff">1167</span>					<span style="color:#66d9ef">if</span> (zero_fill)
<span style="color:#ae81ff">1168</span>						memset((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)p <span style="color:#f92672">+</span> sz <span style="color:#f92672">-</span> mopts.malloc_guard,
<span style="color:#ae81ff">1169</span>						    SOME_JUNK, psz <span style="color:#f92672">-</span> sz);
<span style="color:#ae81ff">1170</span>					<span style="color:#66d9ef">else</span>
<span style="color:#ae81ff">1171</span>						<span style="color:#a6e22e">memset</span>(p, SOME_JUNK,
<span style="color:#ae81ff">1172</span>						    psz <span style="color:#f92672">-</span> mopts.malloc_guard);
</code></pre></div><ul>
<li>
<p>if <code>pool-&gt;malloc_junk == 2</code> is not true then it checks for canaries, that is, <code>else if (mopts.chunk_canaries)</code> then it calls the <code>fill_canary()</code> to fill the canaries</p>
</li>
<li>
<p>coming back to <code>omalloc()</code>, <code>sz &gt; MALLOC_MAXCHUNK</code> has already covered now if requested size is less than the MALLOC_MAXCHUNK then it calls the function <code>malloc_bytes(pool, sz, f);</code> and the defination as given below:</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">948</span>	<span style="color:#75715e">/*
</span><span style="color:#75715e">949	 * Allocate a chunk
</span><span style="color:#75715e">950	 */</span>
<span style="color:#ae81ff">951</span>	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>
<span style="color:#ae81ff">952</span>	malloc_bytes(<span style="color:#66d9ef">struct</span> dir_info <span style="color:#f92672">*</span>d, size_t size, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>f)
<span style="color:#ae81ff">953</span>	{
<span style="color:#ae81ff">954</span>		u_int i, r;
<span style="color:#ae81ff">955</span>		<span style="color:#66d9ef">int</span> j, listnum;
<span style="color:#ae81ff">956</span>		size_t k;
<span style="color:#ae81ff">957</span>		u_short	<span style="color:#f92672">*</span>lp;
<span style="color:#ae81ff">958</span>		<span style="color:#66d9ef">struct</span> chunk_info <span style="color:#f92672">*</span>bp;
<span style="color:#ae81ff">959</span>		<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>p;
<span style="color:#ae81ff">960</span>	
<span style="color:#ae81ff">961</span>		<span style="color:#a6e22e">if</span> (mopts.malloc_canary <span style="color:#f92672">!=</span> (d<span style="color:#f92672">-&gt;</span>canary1 <span style="color:#f92672">^</span> (u_int32_t)(uintptr_t)d) <span style="color:#f92672">||</span>
<span style="color:#ae81ff">962</span>		    d<span style="color:#f92672">-&gt;</span>canary1 <span style="color:#f92672">!=</span> <span style="color:#f92672">~</span>d<span style="color:#f92672">-&gt;</span>canary2)
<span style="color:#ae81ff">963</span>			wrterror(d, <span style="color:#e6db74">&#34;internal struct corrupt&#34;</span>);
<span style="color:#ae81ff">964</span>	
<span style="color:#ae81ff">965</span>		j <span style="color:#f92672">=</span> find_chunksize(size);
<span style="color:#ae81ff">966</span>	
<span style="color:#ae81ff">967</span>		r <span style="color:#f92672">=</span> ((u_int)getrbyte(d) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">8</span>) <span style="color:#f92672">|</span> getrbyte(d);
<span style="color:#ae81ff">968</span>		listnum <span style="color:#f92672">=</span> r <span style="color:#f92672">%</span> MALLOC_CHUNK_LISTS;
<span style="color:#ae81ff">969</span>		<span style="color:#75715e">/* If it&#39;s empty, make a page more of that size chunks */</span>
<span style="color:#ae81ff">970</span>		<span style="color:#66d9ef">if</span> ((bp <span style="color:#f92672">=</span> LIST_FIRST(<span style="color:#f92672">&amp;</span>d<span style="color:#f92672">-&gt;</span>chunk_dir[j][listnum])) <span style="color:#f92672">==</span> NULL) {
<span style="color:#ae81ff">971</span>			bp <span style="color:#f92672">=</span> omalloc_make_chunks(d, j, listnum);
<span style="color:#ae81ff">972</span>			<span style="color:#a6e22e">if</span> (bp <span style="color:#f92672">==</span> NULL)
<span style="color:#ae81ff">973</span>				<span style="color:#66d9ef">return</span> NULL;
<span style="color:#ae81ff">974</span>		}
<span style="color:#ae81ff">975</span>	
<span style="color:#ae81ff">976</span>		<span style="color:#66d9ef">if</span> (bp<span style="color:#f92672">-&gt;</span>canary <span style="color:#f92672">!=</span> (u_short)d<span style="color:#f92672">-&gt;</span>canary1)
<span style="color:#ae81ff">977</span>			wrterror(d, <span style="color:#e6db74">&#34;chunk info corrupted&#34;</span>);
<span style="color:#ae81ff">978</span>	
<span style="color:#ae81ff">979</span>		i <span style="color:#f92672">=</span> (r <span style="color:#f92672">/</span> MALLOC_CHUNK_LISTS) <span style="color:#f92672">&amp;</span> (bp<span style="color:#f92672">-&gt;</span>total <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
<span style="color:#ae81ff">980</span>	
<span style="color:#ae81ff">981</span>		<span style="color:#75715e">/* start somewhere in a short */</span>
<span style="color:#ae81ff">982</span>		lp <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>bp<span style="color:#f92672">-&gt;</span>bits[i <span style="color:#f92672">/</span> MALLOC_BITS];
<span style="color:#ae81ff">983</span>		<span style="color:#a6e22e">if</span> (<span style="color:#f92672">*</span>lp) {
<span style="color:#ae81ff">984</span>			j <span style="color:#f92672">=</span> i <span style="color:#f92672">%</span> MALLOC_BITS;
<span style="color:#ae81ff">985</span>			k <span style="color:#f92672">=</span> ffs(<span style="color:#f92672">*</span>lp <span style="color:#f92672">&gt;&gt;</span> j);
<span style="color:#ae81ff">986</span>			<span style="color:#66d9ef">if</span> (k <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
<span style="color:#ae81ff">987</span>				k <span style="color:#f92672">+=</span> j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
<span style="color:#ae81ff">988</span>				<span style="color:#66d9ef">goto</span> found;
<span style="color:#ae81ff">989</span>			}
<span style="color:#ae81ff">990</span>		}
<span style="color:#ae81ff">991</span>		<span style="color:#75715e">/* no bit halfway, go to next full short */</span>
<span style="color:#ae81ff">992</span>		i <span style="color:#f92672">/=</span> MALLOC_BITS;
<span style="color:#ae81ff">993</span>		<span style="color:#66d9ef">for</span> (;;) {
<span style="color:#ae81ff">994</span>			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">++</span>i <span style="color:#f92672">&gt;=</span> bp<span style="color:#f92672">-&gt;</span>total <span style="color:#f92672">/</span> MALLOC_BITS)
<span style="color:#ae81ff">995</span>				i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#ae81ff">996</span>			lp <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>bp<span style="color:#f92672">-&gt;</span>bits[i];
<span style="color:#ae81ff">997</span>			<span style="color:#a6e22e">if</span> (<span style="color:#f92672">*</span>lp) {
<span style="color:#ae81ff">998</span>				k <span style="color:#f92672">=</span> ffs(<span style="color:#f92672">*</span>lp) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
<span style="color:#ae81ff">999</span>				<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">1000</span>			}
<span style="color:#ae81ff">1001</span>		}
<span style="color:#ae81ff">1002</span>	found:
<span style="color:#ae81ff">1003</span>	<span style="color:#960050;background-color:#1e0010">#</span>ifdef MALLOC_STATS
<span style="color:#ae81ff">1004</span>		<span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> k <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
<span style="color:#ae81ff">1005</span>			<span style="color:#66d9ef">struct</span> region_info <span style="color:#f92672">*</span>r <span style="color:#f92672">=</span> find(d, bp<span style="color:#f92672">-&gt;</span>page);
<span style="color:#ae81ff">1006</span>			r<span style="color:#f92672">-&gt;</span>f <span style="color:#f92672">=</span> f;
<span style="color:#ae81ff">1007</span>		}
<span style="color:#ae81ff">1008</span>	<span style="color:#960050;background-color:#1e0010">#</span>endif
<span style="color:#ae81ff">1009</span>	
<span style="color:#ae81ff">1010</span>		<span style="color:#f92672">*</span>lp <span style="color:#f92672">^=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> k;
<span style="color:#ae81ff">1011</span>	
<span style="color:#ae81ff">1012</span>		<span style="color:#75715e">/* If there are no more free, remove from free-list */</span>
<span style="color:#ae81ff">1013</span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">--</span>bp<span style="color:#f92672">-&gt;</span>free <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
<span style="color:#ae81ff">1014</span>			LIST_REMOVE(bp, entries);
<span style="color:#ae81ff">1015</span>	
<span style="color:#ae81ff">1016</span>		<span style="color:#75715e">/* Adjust to the real offset of that chunk */</span>
<span style="color:#ae81ff">1017</span>		k <span style="color:#f92672">+=</span> (lp <span style="color:#f92672">-</span> bp<span style="color:#f92672">-&gt;</span>bits) <span style="color:#f92672">*</span> MALLOC_BITS;
<span style="color:#ae81ff">1018</span>	
<span style="color:#ae81ff">1019</span>		<span style="color:#a6e22e">if</span> (mopts.chunk_canaries <span style="color:#f92672">&amp;&amp;</span> size <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
<span style="color:#ae81ff">1020</span>			bp<span style="color:#f92672">-&gt;</span>bits[bp<span style="color:#f92672">-&gt;</span>offset <span style="color:#f92672">+</span> k] <span style="color:#f92672">=</span> size;
<span style="color:#ae81ff">1021</span>	
<span style="color:#ae81ff">1022</span>		k <span style="color:#f92672">&lt;&lt;=</span> bp<span style="color:#f92672">-&gt;</span>shift;
<span style="color:#ae81ff">1023</span>	
<span style="color:#ae81ff">1024</span>		p <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)bp<span style="color:#f92672">-&gt;</span>page <span style="color:#f92672">+</span> k;
<span style="color:#ae81ff">1025</span>		<span style="color:#a6e22e">if</span> (bp<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
<span style="color:#ae81ff">1026</span>			<span style="color:#66d9ef">if</span> (d<span style="color:#f92672">-&gt;</span>malloc_junk <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>)
<span style="color:#ae81ff">1027</span>				memset(p, SOME_JUNK, bp<span style="color:#f92672">-&gt;</span>size);
<span style="color:#ae81ff">1028</span>			<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (mopts.chunk_canaries)
<span style="color:#ae81ff">1029</span>				fill_canary(p, size, bp<span style="color:#f92672">-&gt;</span>size);
<span style="color:#ae81ff">1030</span>		}
<span style="color:#ae81ff">1031</span>		<span style="color:#66d9ef">return</span> p;
<span style="color:#ae81ff">1032</span>	}
</code></pre></div><ul>
<li><code>malloc_bytes(pool, sz, f);</code> is used to allocate a chunk and after some basic variable declarations, it checks for internal structure corruption with canaries of <strong>d</strong> and <strong>mopts.malloc_canary</strong></li>
<li>Then, it finds the chunk size with the function <code>find_chunksize(size);</code>, defination as given below:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">919</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span>
<span style="color:#ae81ff">920</span> <span style="color:#a6e22e">find_chunksize</span>(size_t size)
<span style="color:#ae81ff">921</span> {
<span style="color:#ae81ff">922</span>         <span style="color:#66d9ef">int</span> r;
<span style="color:#ae81ff">923</span>
<span style="color:#ae81ff">924</span>         <span style="color:#75715e">/* malloc(0) is special */</span>
<span style="color:#ae81ff">925</span>         <span style="color:#66d9ef">if</span> (size <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
<span style="color:#ae81ff">926</span>                 <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
<span style="color:#ae81ff">927</span>
<span style="color:#ae81ff">928</span>         <span style="color:#66d9ef">if</span> (size <span style="color:#f92672">&lt;</span> MALLOC_MINSIZE)
<span style="color:#ae81ff">929</span>                 size <span style="color:#f92672">=</span> MALLOC_MINSIZE;
<span style="color:#ae81ff">930</span>         size<span style="color:#f92672">--</span>;
<span style="color:#ae81ff">931</span>
<span style="color:#ae81ff">932</span>         r <span style="color:#f92672">=</span> MALLOC_MINSHIFT;
<span style="color:#ae81ff">933</span>         <span style="color:#66d9ef">while</span> (size <span style="color:#f92672">&gt;&gt;</span> r)
<span style="color:#ae81ff">934</span>                 r<span style="color:#f92672">++</span>;
<span style="color:#ae81ff">935</span>         <span style="color:#66d9ef">return</span> r;
<span style="color:#ae81ff">936</span> } 
</code></pre></div><ul>
<li>first it will check if given size is <strong>0</strong> then it returns <strong>0</strong>, then it checks if size is less than MALLOC_MINSIZE then it sets size to MALLOC_MINSIZE, else, it decrements the size and sets <code>r = MALLOC_MINSHIFT;</code> and the value of MALLOC_MINSHIFT is <strong>4</strong>. Then it right shifts the <strong>size</strong> by <strong>r</strong> and it keeps incrementing the <strong>r</strong> till right shifting result becomes zero, then returns <strong>r</strong>. In our case, the size is 8, which is less than MALLOC_MINSIZE and then it sets the size to MALLOC_MINSIZE, which is 16, then it decrements and it becomes 15 and <strong>15 &raquo; 4</strong>, as we know <strong>r</strong> is MALLOC_MINSHIFT, which is 4. So, the output of <strong>15 &raquo;4</strong> is 0 then it returns r, which is 4</li>
<li>coming back to <code>malloc_bytes()</code> after find_chunksize(size), it calls <code>((u_int)getrbyte(d) &lt;&lt; 8) | getrbyte(d);</code>, so, defination of <code>getrbyte(d)</code> as given below:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">311</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> u_char
<span style="color:#ae81ff">312</span> <span style="color:#a6e22e">getrbyte</span>(<span style="color:#66d9ef">struct</span> dir_info <span style="color:#f92672">*</span>d)
<span style="color:#ae81ff">313</span> {
<span style="color:#ae81ff">314</span>         u_char x;
<span style="color:#ae81ff">315</span> 
<span style="color:#ae81ff">316</span>         <span style="color:#66d9ef">if</span> (d<span style="color:#f92672">-&gt;</span>rbytesused <span style="color:#f92672">&gt;=</span> <span style="color:#66d9ef">sizeof</span>(d<span style="color:#f92672">-&gt;</span>rbytes))
<span style="color:#ae81ff">317</span>                 rbytes_init(d);
<span style="color:#ae81ff">318</span>         x <span style="color:#f92672">=</span> d<span style="color:#f92672">-&gt;</span>rbytes[d<span style="color:#f92672">-&gt;</span>rbytesused<span style="color:#f92672">++</span>];
<span style="color:#ae81ff">319</span>         <span style="color:#66d9ef">return</span> x;
<span style="color:#ae81ff">320</span> }
</code></pre></div><ul>
<li>in the above code, first it checks whether the <strong>rbytesused</strong> is more than the sizeof(rbytes), if yes, then it initializes the random bytes using <code>rbytes_init(d)</code> and then assigns the value of <code>d-&gt;rbytes[d-&gt;rbytesused]</code> to x and also increments the <strong>d-&gt;rbytesused</strong> count and returns the same but if the condition fails then it will directly assigns the rbytesused count to x and increment the same and return the same x</li>
<li>So as per the name indicates, my feeling is that the getrbyte() means get-random-byte(), basically the whole line <code>r = ((u_int)getrbyte(d) &lt;&lt; 8) | getrbyte(d);</code> does the following magic</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">get-random-byte then left shits by 8 then OR&#39;ed with again some random byte
let&#39;s suppose,
1) a =  get-random-bytes
2) left shift a by 8 
3) b = get-random-bytes
4) r = a | b
for example, 0xd4 -&gt; 0xd400 -&gt; 0xd4cb, so r = 0xd4cb` 
</code></pre></div><ul>
<li>Then it finds the listnum, <code>listnum = r % MALLOC_CHUNK_LISTS;</code>, where MALLOC_CHUNK_LISTS is 4</li>
<li>as per our understanding about the for loops on randomization, we have seen that there is nested for loops which creates lists, helpful to allow randomization. So, here we can see that it randomly chooses the created lists for allocation of <code>chunk_info</code></li>
<li>then, it chooses some random list and makes it first list, now if the list is empty, that is, head is NULL then it calls function <code>omalloc_make_chunks(d, j, listnum);</code> to allocate page of chunks. Defination of <code>omalloc_make_chunks()</code> as given below:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">885</span> <span style="color:#75715e">/*
</span><span style="color:#75715e">886  * Allocate a page of chunks
</span><span style="color:#75715e">887  */</span>
<span style="color:#ae81ff">888</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> chunk_info <span style="color:#f92672">*</span>
<span style="color:#ae81ff">889</span> omalloc_make_chunks(<span style="color:#66d9ef">struct</span> dir_info <span style="color:#f92672">*</span>d, <span style="color:#66d9ef">int</span> bits, <span style="color:#66d9ef">int</span> listnum)
<span style="color:#ae81ff">890</span> {
<span style="color:#ae81ff">891</span>         <span style="color:#66d9ef">struct</span> chunk_info <span style="color:#f92672">*</span>bp;
<span style="color:#ae81ff">892</span>         <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>pp;
<span style="color:#ae81ff">893</span>
<span style="color:#ae81ff">894</span>         <span style="color:#75715e">/* Allocate a new bucket */</span>
<span style="color:#ae81ff">895</span>         pp <span style="color:#f92672">=</span> map(d, NULL, MALLOC_PAGESIZE, <span style="color:#ae81ff">0</span>);
<span style="color:#ae81ff">896</span>         <span style="color:#a6e22e">if</span> (pp <span style="color:#f92672">==</span> MAP_FAILED)
<span style="color:#ae81ff">897</span>                 <span style="color:#66d9ef">return</span> NULL;
<span style="color:#ae81ff">898</span>
<span style="color:#ae81ff">899</span>         <span style="color:#75715e">/* memory protect the page allocated in the malloc(0) case */</span>
<span style="color:#ae81ff">900</span>         <span style="color:#66d9ef">if</span> (bits <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> mprotect(pp, MALLOC_PAGESIZE, PROT_NONE) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
<span style="color:#ae81ff">901</span>                 <span style="color:#66d9ef">goto</span> err;
<span style="color:#ae81ff">902</span>
<span style="color:#ae81ff">903</span>         bp <span style="color:#f92672">=</span> alloc_chunk_info(d, bits);
<span style="color:#ae81ff">904</span>         <span style="color:#a6e22e">if</span> (bp <span style="color:#f92672">==</span> NULL)
<span style="color:#ae81ff">905</span>                 <span style="color:#66d9ef">goto</span> err;
<span style="color:#ae81ff">906</span>         bp<span style="color:#f92672">-&gt;</span>page <span style="color:#f92672">=</span> pp;
<span style="color:#ae81ff">907</span>
<span style="color:#ae81ff">908</span>         <span style="color:#a6e22e">if</span> (insert(d, (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)((uintptr_t)pp <span style="color:#f92672">|</span> (bits <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)), (uintptr_t)bp,
<span style="color:#ae81ff">909</span>             NULL))
<span style="color:#ae81ff">910</span>                 <span style="color:#66d9ef">goto</span> err;
<span style="color:#ae81ff">911</span>         <span style="color:#a6e22e">LIST_INSERT_HEAD</span>(<span style="color:#f92672">&amp;</span>d<span style="color:#f92672">-&gt;</span>chunk_dir[bits][listnum], bp, entries);
<span style="color:#ae81ff">912</span>         <span style="color:#66d9ef">return</span> bp;
<span style="color:#ae81ff">913</span>
<span style="color:#ae81ff">914</span> err:
<span style="color:#ae81ff">915</span>         unmap(d, pp, MALLOC_PAGESIZE, <span style="color:#ae81ff">0</span>, d<span style="color:#f92672">-&gt;</span>malloc_junk);
<span style="color:#ae81ff">916</span>         <span style="color:#66d9ef">return</span> NULL;
<span style="color:#ae81ff">917</span> }
</code></pre></div><ul>
<li>The above code is used to allocate a page of chunks, as mentioned in the comments. First, it maps/allocates page up to len MALLOC_PAGESIZE with hint addr as NULL using <code>map(d, NULL, MALLOC_PAGESIZE, 0);</code>, then it checks for its failure and returns NULL if fails. Defination of <code>map()</code> as given below</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">751</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>
<span style="color:#ae81ff">752</span> <span style="color:#a6e22e">map</span>(<span style="color:#66d9ef">struct</span> dir_info <span style="color:#f92672">*</span>d, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>hint, size_t sz, <span style="color:#66d9ef">int</span> zero_fill)
<span style="color:#ae81ff">753</span> {
<span style="color:#ae81ff">754</span>	size_t psz <span style="color:#f92672">=</span> sz <span style="color:#f92672">&gt;&gt;</span> MALLOC_PAGESHIFT;
<span style="color:#ae81ff">755</span>	<span style="color:#66d9ef">struct</span> region_info <span style="color:#f92672">*</span>r, <span style="color:#f92672">*</span>big <span style="color:#f92672">=</span> NULL;
<span style="color:#ae81ff">756</span>	u_int i;
<span style="color:#ae81ff">757</span>	<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>p;
<span style="color:#ae81ff">758</span> 
<span style="color:#ae81ff">759</span>	<span style="color:#66d9ef">if</span> (mopts.malloc_canary <span style="color:#f92672">!=</span> (d<span style="color:#f92672">-&gt;</span>canary1 <span style="color:#f92672">^</span> (u_int32_t)(uintptr_t)d) <span style="color:#f92672">||</span>
<span style="color:#ae81ff">760</span>	    d<span style="color:#f92672">-&gt;</span>canary1 <span style="color:#f92672">!=</span> <span style="color:#f92672">~</span>d<span style="color:#f92672">-&gt;</span>canary2)
<span style="color:#ae81ff">761</span>		wrterror(d, <span style="color:#e6db74">&#34;internal struct corrupt&#34;</span>);
<span style="color:#ae81ff">762</span>	<span style="color:#66d9ef">if</span> (sz <span style="color:#f92672">!=</span> PAGEROUND(sz))
<span style="color:#ae81ff">763</span>		wrterror(d, <span style="color:#e6db74">&#34;map round&#34;</span>);
<span style="color:#ae81ff">764</span> 
<span style="color:#ae81ff">765</span>	<span style="color:#66d9ef">if</span> (hint <span style="color:#f92672">==</span> NULL <span style="color:#f92672">&amp;&amp;</span> psz <span style="color:#f92672">&gt;</span> d<span style="color:#f92672">-&gt;</span>free_regions_size) {
<span style="color:#ae81ff">766</span>		_MALLOC_LEAVE(d);
<span style="color:#ae81ff">767</span>		p <span style="color:#f92672">=</span> MMAP(sz, d<span style="color:#f92672">-&gt;</span>mmap_flag);
<span style="color:#ae81ff">768</span>		_MALLOC_ENTER(d);
<span style="color:#ae81ff">769</span>		<span style="color:#66d9ef">if</span> (p <span style="color:#f92672">!=</span> MAP_FAILED)
<span style="color:#ae81ff">770</span>			STATS_ADD(d<span style="color:#f92672">-&gt;</span>malloc_used, sz);
<span style="color:#ae81ff">771</span>		<span style="color:#75715e">/* zero fill not needed */</span>
<span style="color:#ae81ff">772</span>		<span style="color:#66d9ef">return</span> p;
<span style="color:#ae81ff">773</span>	}
<span style="color:#ae81ff">774</span>	<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> d<span style="color:#f92672">-&gt;</span>malloc_cache; i<span style="color:#f92672">++</span>) {
<span style="color:#ae81ff">775</span>		r <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>d<span style="color:#f92672">-&gt;</span>free_regions[(i <span style="color:#f92672">+</span> d<span style="color:#f92672">-&gt;</span>rotor) <span style="color:#f92672">&amp;</span> (d<span style="color:#f92672">-&gt;</span>malloc_cache <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)];
<span style="color:#ae81ff">776</span>		<span style="color:#66d9ef">if</span> (r<span style="color:#f92672">-&gt;</span>p <span style="color:#f92672">!=</span> NULL) {
<span style="color:#ae81ff">777</span>			<span style="color:#66d9ef">if</span> (hint <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> r<span style="color:#f92672">-&gt;</span>p <span style="color:#f92672">!=</span> hint)
<span style="color:#ae81ff">778</span>				<span style="color:#66d9ef">continue</span>;
<span style="color:#ae81ff">779</span>			<span style="color:#66d9ef">if</span> (r<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">==</span> psz) {
<span style="color:#ae81ff">780</span>				p <span style="color:#f92672">=</span> r<span style="color:#f92672">-&gt;</span>p;
<span style="color:#ae81ff">781</span>				r<span style="color:#f92672">-&gt;</span>p <span style="color:#f92672">=</span> NULL;
<span style="color:#ae81ff">782</span>				d<span style="color:#f92672">-&gt;</span>free_regions_size <span style="color:#f92672">-=</span> psz;
<span style="color:#ae81ff">783</span>				<span style="color:#66d9ef">if</span> (mopts.malloc_freeunmap)
<span style="color:#ae81ff">784</span>					mprotect(p, sz, PROT_READ <span style="color:#f92672">|</span> PROT_WRITE);
<span style="color:#ae81ff">785</span>				<span style="color:#66d9ef">if</span> (zero_fill)
<span style="color:#ae81ff">786</span>					memset(p, <span style="color:#ae81ff">0</span>, sz);
<span style="color:#ae81ff">787</span>				<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (d<span style="color:#f92672">-&gt;</span>malloc_junk <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span>
<span style="color:#ae81ff">788</span>				    mopts.malloc_freeunmap)
<span style="color:#ae81ff">789</span>					memset(p, SOME_FREEJUNK, sz);
<span style="color:#ae81ff">790</span>				d<span style="color:#f92672">-&gt;</span>rotor <span style="color:#f92672">+=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
<span style="color:#ae81ff">791</span>				<span style="color:#66d9ef">return</span> p;
<span style="color:#ae81ff">792</span>			} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (r<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">&gt;</span> psz)
<span style="color:#ae81ff">793</span>				big <span style="color:#f92672">=</span> r;
<span style="color:#ae81ff">794</span>		}
<span style="color:#ae81ff">795</span>	}
<span style="color:#ae81ff">796</span>	<span style="color:#66d9ef">if</span> (big <span style="color:#f92672">!=</span> NULL) {
<span style="color:#ae81ff">797</span>		r <span style="color:#f92672">=</span> big;
<span style="color:#ae81ff">798</span>		p <span style="color:#f92672">=</span> r<span style="color:#f92672">-&gt;</span>p;
<span style="color:#ae81ff">799</span>		r<span style="color:#f92672">-&gt;</span>p <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)r<span style="color:#f92672">-&gt;</span>p <span style="color:#f92672">+</span> (psz <span style="color:#f92672">&lt;&lt;</span> MALLOC_PAGESHIFT);
<span style="color:#ae81ff">800</span>		<span style="color:#66d9ef">if</span> (mopts.malloc_freeunmap)
<span style="color:#ae81ff">801</span>			mprotect(p, sz, PROT_READ <span style="color:#f92672">|</span> PROT_WRITE);
<span style="color:#ae81ff">802</span>		r<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">-=</span> psz;
<span style="color:#ae81ff">803</span>		d<span style="color:#f92672">-&gt;</span>free_regions_size <span style="color:#f92672">-=</span> psz;
<span style="color:#ae81ff">804</span>		<span style="color:#66d9ef">if</span> (zero_fill)
<span style="color:#ae81ff">805</span>			memset(p, <span style="color:#ae81ff">0</span>, sz);
<span style="color:#ae81ff">806</span>		<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (d<span style="color:#f92672">-&gt;</span>malloc_junk <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> mopts.malloc_freeunmap)
<span style="color:#ae81ff">807</span>			memset(p, SOME_FREEJUNK, sz);
<span style="color:#ae81ff">808</span>		<span style="color:#66d9ef">return</span> p;
<span style="color:#ae81ff">809</span>	}
<span style="color:#ae81ff">810</span>	<span style="color:#66d9ef">if</span> (hint <span style="color:#f92672">!=</span> NULL)
<span style="color:#ae81ff">811</span>		<span style="color:#66d9ef">return</span> MAP_FAILED;
<span style="color:#ae81ff">812</span>	<span style="color:#66d9ef">if</span> (d<span style="color:#f92672">-&gt;</span>free_regions_size <span style="color:#f92672">&gt;</span> d<span style="color:#f92672">-&gt;</span>malloc_cache)
<span style="color:#ae81ff">813</span>		wrterror(d, <span style="color:#e6db74">&#34;malloc cache&#34;</span>);
<span style="color:#ae81ff">814</span>	_MALLOC_LEAVE(d);
<span style="color:#ae81ff">815</span>	p <span style="color:#f92672">=</span> MMAP(sz, d<span style="color:#f92672">-&gt;</span>mmap_flag);
<span style="color:#ae81ff">816</span>	_MALLOC_ENTER(d);
<span style="color:#ae81ff">817</span>	<span style="color:#66d9ef">if</span> (p <span style="color:#f92672">!=</span> MAP_FAILED)
<span style="color:#ae81ff">818</span>		STATS_ADD(d<span style="color:#f92672">-&gt;</span>malloc_used, sz);
<span style="color:#ae81ff">819</span>	<span style="color:#75715e">/* zero fill not needed */</span>
<span style="color:#ae81ff">820</span>	<span style="color:#66d9ef">return</span> p;
<span style="color:#ae81ff">821</span> }
</code></pre></div><ul>
<li>parameters for the map() function given below:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">calls map(d, NULL, MALLOC_PAGESIZE, 0);
    first parameter, d belongs to struct dir_info *d
    second parameter, NULL belongs to *hint
	third parameter, MALLOC_PAGESIZE belongs to sz
	fourth parameter, 0 indicates zero_filling requirements 
</code></pre></div><ul>
<li>
<p>First, <code>map()</code> assigns the right shifted value of sz by MALLOC_PAGESHIFT bytes, which is 4096 &raquo; 12 =&gt; 0x1. So, psz = 0x1 then, it defines some pointer objects for the structure <strong>region_info</strong> and some other pointer variables, later, it checks for internal struct corruption through canaries. Then, it verifies the roundness of size sz. if it passes, then it checks whether the provided hint is NULL and psz is greater than free_pages_cache. So, for our case, the d-&gt;free_regions_size is 0x0 and psz is 0x1 and the condition satisfies and it comes under <code>if</code> code, where <code>if</code> code first does MALLOC_LEAVE, which means it checks if it is multi-threaded program then decrement the d-&gt;active count and unlock malloc and returns but if it is single-threaded like for our case, then it simply returns without doing anything</p>
</li>
<li>
<p>Then, it maps pages with provided flag mmap_flag and size sz. mmap_flag is 0x0, as if we remember correctly then second time <code>getpool()</code> returns <strong>d</strong> with mmap_flag is 0x0. Then, it does MALLOC_ENTER which is the opposite of MALLOC_LEAVE which means check if the program is multi-threaded then lock malloc and increment the d-&gt;active count but if the program is single-threaded then it does nothing and simply returns. Then , it checks whether p is failed. If not then it adds stats information, that is, increments the d-&gt;malloc_used to sz, that is, <code>d-&gt;malloc_used += sz</code> then it returns <code>p</code></p>
</li>
<li>
<p>For our case, map() completed but other code paths may be explained later in the upcoming malloc series, as the blog has already become lengthy</p>
</li>
<li>
<p>Then, coming back to <code>omalloc_make_chunks()</code>, if the bits is 0 means for <strong>malloc(0)</strong> case, it memory protects the allocated page with <strong>PROT_NONE</strong> but for our case, bits is 4 and we have used <strong>malloc(8)</strong></p>
</li>
<li>
<p>Then, it allocates the chunk info by calling the function <code>alloc_chunk_info(d, bits);</code> and code for the same given below:</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">847</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> chunk_info <span style="color:#f92672">*</span>
<span style="color:#ae81ff">848</span> <span style="color:#a6e22e">alloc_chunk_info</span>(<span style="color:#66d9ef">struct</span> dir_info <span style="color:#f92672">*</span>d, <span style="color:#66d9ef">int</span> bits)
<span style="color:#ae81ff">849</span> {
<span style="color:#ae81ff">850</span>         <span style="color:#66d9ef">struct</span> chunk_info <span style="color:#f92672">*</span>p;
<span style="color:#ae81ff">851</span>
<span style="color:#ae81ff">852</span>         <span style="color:#66d9ef">if</span> (LIST_EMPTY(<span style="color:#f92672">&amp;</span>d<span style="color:#f92672">-&gt;</span>chunk_info_list[bits])) {
<span style="color:#ae81ff">853</span>                 size_t size, count, i;
<span style="color:#ae81ff">854</span>                 <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>q;
<span style="color:#ae81ff">855</span>
<span style="color:#ae81ff">856</span>                 <span style="color:#66d9ef">if</span> (bits <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
<span style="color:#ae81ff">857</span>                         count <span style="color:#f92672">=</span> MALLOC_PAGESIZE <span style="color:#f92672">/</span> MALLOC_MINSIZE;
<span style="color:#ae81ff">858</span>                 <span style="color:#66d9ef">else</span>
<span style="color:#ae81ff">859</span>                         count <span style="color:#f92672">=</span> MALLOC_PAGESIZE <span style="color:#f92672">&gt;&gt;</span> bits;
<span style="color:#ae81ff">860</span>
<span style="color:#ae81ff">861</span>                 size <span style="color:#f92672">=</span> howmany(count, MALLOC_BITS);
<span style="color:#ae81ff">862</span>                 size <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> chunk_info) <span style="color:#f92672">+</span> (size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(u_short);
<span style="color:#ae81ff">863</span>                 <span style="color:#66d9ef">if</span> (mopts.chunk_canaries)
<span style="color:#ae81ff">864</span>                         size <span style="color:#f92672">+=</span> count <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(u_short);
<span style="color:#ae81ff">865</span>                 size <span style="color:#f92672">=</span> _ALIGN(size);
<span style="color:#ae81ff">866</span>
<span style="color:#ae81ff">867</span>                 q <span style="color:#f92672">=</span> MMAP(MALLOC_PAGESIZE, d<span style="color:#f92672">-&gt;</span>mmap_flag);
<span style="color:#ae81ff">868</span>                 <span style="color:#66d9ef">if</span> (q <span style="color:#f92672">==</span> MAP_FAILED)
<span style="color:#ae81ff">869</span>                         <span style="color:#66d9ef">return</span> NULL;
<span style="color:#ae81ff">870</span>                 STATS_ADD(d<span style="color:#f92672">-&gt;</span>malloc_used, MALLOC_PAGESIZE);
<span style="color:#ae81ff">871</span>                 count <span style="color:#f92672">=</span> MALLOC_PAGESIZE <span style="color:#f92672">/</span> size;
<span style="color:#ae81ff">872</span>
<span style="color:#ae81ff">873</span>                 <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> count; i<span style="color:#f92672">++</span>, q <span style="color:#f92672">+=</span> size) {
<span style="color:#ae81ff">874</span>                         p <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> chunk_info <span style="color:#f92672">*</span>)q;
<span style="color:#ae81ff">875</span>                         LIST_INSERT_HEAD(<span style="color:#f92672">&amp;</span>d<span style="color:#f92672">-&gt;</span>chunk_info_list[bits], p, entries);
<span style="color:#ae81ff">876</span>                 }
<span style="color:#ae81ff">877</span>         }
<span style="color:#ae81ff">878</span>         p <span style="color:#f92672">=</span> LIST_FIRST(<span style="color:#f92672">&amp;</span>d<span style="color:#f92672">-&gt;</span>chunk_info_list[bits]);
<span style="color:#ae81ff">879</span>         LIST_REMOVE(p, entries);
<span style="color:#ae81ff">880</span>         <span style="color:#66d9ef">if</span> (p<span style="color:#f92672">-&gt;</span>shift <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
<span style="color:#ae81ff">881</span>                 init_chunk_info(d, p, bits);
<span style="color:#ae81ff">882</span>         <span style="color:#66d9ef">return</span> p;
<span style="color:#ae81ff">883</span> }
</code></pre></div><ul>
<li>First it checks if the list is empty where bits is 4 for our case, and if it is empty then it checks if bits is 0, if yes, then it calculates the count by dividing the MALLOC_PAGESIZE with MALLOC_MINSIZE but in our case bits is equals to 4, so, it calculates count for all cases when bit != 0 by <strong>MALLOC_PAGESIZE &raquo; bits</strong>, which comes as 256 for our case</li>
<li>Then, howmany(x, y) is ((x) + ((y) - 1) / y), so as per that, x = count and y is MALLOC_BITS, which is 256 and 16 respectively for our case and the result is 16</li>
<li>Then, it calculates size from adding the <code>sizeof(struct chunk_info) + (size - 1) * sizeof(u_short)</code>, for our case, it came as <code>40 + (16 - 1) * 2 = 70</code> and then it checks for mopt.chunk_canaries and if it is there then it calculates <code>size += count * sizeof(u_short);</code> remember we have compiled our sample code with malloc option <strong>C</strong>, so, chunk_canaries is there, for our case size became, <code>size = 70 + 256 * 2 = 582</code> then it aligns the size to <code>ALIGN(size)</code>, which make it from 582 to 584</li>
<li>In simpler words, the above point explains the size calculations for a chunk. It includes the <code>size = [size of structure chunk_info] + [ size of bitmap]</code> and as we already know that the bits will be different for different chunk size, so, the size of bitmap varies as per the different bits. It also adds the size of canary, if enable</li>
<li>Then, it maps page using mmap(2) upto MALLOC_PAGESIZE with mmap_flag value as 0 due to the mopts.malloc_pool[1], mopts.malloc_pool[0] has MAP_CONCEALed memory.Then, it adds information about malloc usage count from adding MALLOC_PAGESIZE to variable d-&gt;malloc_used. Then, it calculates count from <code>count = MALLOC_PAGESIZE / size</code> where it is 4096 / 584 = 7, for our case</li>
<li>Then, it creates count number of lists for chunk_info. For our case, count is 7 so, it creates 7 lists with the list head updated with p. Then, it chooses first list or in other words we can say it chooses the last inserted head list then removes it from the lists. Then it checks for p-&gt;shift and here shift means how may shifts it will take to get the p-&gt;size, if it is zero (0) then it calls function <code>init_chunk_info(d, p, bits);</code> then after the initializaton it returns <strong>p</strong>. Defination of the <code>init_chunk_info()</code> as given below:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">823</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>
<span style="color:#ae81ff">824</span> <span style="color:#a6e22e">init_chunk_info</span>(<span style="color:#66d9ef">struct</span> dir_info <span style="color:#f92672">*</span>d, <span style="color:#66d9ef">struct</span> chunk_info <span style="color:#f92672">*</span>p, <span style="color:#66d9ef">int</span> bits)
<span style="color:#ae81ff">825</span> {
<span style="color:#ae81ff">826</span>         <span style="color:#66d9ef">int</span> i;
<span style="color:#ae81ff">827</span>
<span style="color:#ae81ff">828</span>         <span style="color:#66d9ef">if</span> (bits <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
<span style="color:#ae81ff">829</span>                 p<span style="color:#f92672">-&gt;</span>shift <span style="color:#f92672">=</span> MALLOC_MINSHIFT;
<span style="color:#ae81ff">830</span>                 p<span style="color:#f92672">-&gt;</span>total <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>free <span style="color:#f92672">=</span> MALLOC_PAGESIZE <span style="color:#f92672">&gt;&gt;</span> p<span style="color:#f92672">-&gt;</span>shift;
<span style="color:#ae81ff">831</span>                 p<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#ae81ff">832</span>                 p<span style="color:#f92672">-&gt;</span>offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xdead</span>;
<span style="color:#ae81ff">833</span>         } <span style="color:#66d9ef">else</span> {
<span style="color:#ae81ff">834</span>                 p<span style="color:#f92672">-&gt;</span>shift <span style="color:#f92672">=</span> bits;
<span style="color:#ae81ff">835</span>                 p<span style="color:#f92672">-&gt;</span>total <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>free <span style="color:#f92672">=</span> MALLOC_PAGESIZE <span style="color:#f92672">&gt;&gt;</span> p<span style="color:#f92672">-&gt;</span>shift;
<span style="color:#ae81ff">836</span>                 p<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">=</span> <span style="color:#ae81ff">1U</span> <span style="color:#f92672">&lt;&lt;</span> bits;
<span style="color:#ae81ff">837</span>                 p<span style="color:#f92672">-&gt;</span>offset <span style="color:#f92672">=</span> howmany(p<span style="color:#f92672">-&gt;</span>total, MALLOC_BITS);
<span style="color:#ae81ff">838</span>         }
<span style="color:#ae81ff">839</span>         p<span style="color:#f92672">-&gt;</span>canary <span style="color:#f92672">=</span> (u_short)d<span style="color:#f92672">-&gt;</span>canary1;
<span style="color:#ae81ff">840</span>
<span style="color:#ae81ff">841</span>         <span style="color:#75715e">/* set all valid bits in the bitmap */</span>
<span style="color:#ae81ff">842</span>         i <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>total <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
<span style="color:#ae81ff">843</span>         memset(p<span style="color:#f92672">-&gt;</span>bits, <span style="color:#ae81ff">0xff</span>, <span style="color:#66d9ef">sizeof</span>(p<span style="color:#f92672">-&gt;</span>bits[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">*</span> (i <span style="color:#f92672">/</span> MALLOC_BITS));
<span style="color:#ae81ff">844</span>         p<span style="color:#f92672">-&gt;</span>bits[i <span style="color:#f92672">/</span> MALLOC_BITS] <span style="color:#f92672">=</span> (<span style="color:#ae81ff">2U</span> <span style="color:#f92672">&lt;&lt;</span> (i <span style="color:#f92672">%</span> MALLOC_BITS)) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
<span style="color:#ae81ff">845</span> }
</code></pre></div><ul>
<li><code>init_chunk_info()</code> is used to initialize the chunk information. It checks for whether the value of bits is 0 or not and if 0 then it initializes some default value as mentioned in the code and it seems that <code>bit == 0</code>, is the case of malloc(0) but if it is not 0 then it initializes some other values as mentioned in the code. Then, it assigns <strong>dir_info</strong> canary1 to chunk canary with typecasts in u_short, that is <code>p-&gt;canary = (u_short)d-&gt;canary1;</code></li>
<li>Then, set all the valid bits in the bitmap. For our case, <code>i = p-&gt;total - 1;</code>, where p-&gt;total = 256 and i = 255 then it copies the 0xff to p-&gt;bits upto <code>sizeof(p-&gt;bits[0]) * (i / MALLOC_BITS)) - 1</code> which we have observed 30 for our case.</li>
<li>Then it assigns some value to p-&gt;bits, where a bitmap specifing which chunks are still free to use, for better explanation on <strong>p-&gt;bits</strong>, for our case, i = 255, MALLOC_BITS = 16, so, it becomes,</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">p-&gt;bits[255 / 16] = (2U &lt;&lt; ( 255 % 16)) - 1
	then, p-&gt;bits[15] = (2U &lt;&lt; ( 15 )) - 1
	then, p-&gt;bits[15] = 65536 - 1
	then, p-&gt;bits[15] = 65535
</code></pre></div><ul>
<li>Now, the chunk initializaton is completed, we can see that after the function <code>init_chunk_info(d, p, bits);</code>, it returns the initialized chunk <strong>p</strong></li>
<li>after the completion of both the functions <strong>init_chunk_info()</strong> and <strong>alloc_chunk_info()</strong>, it returns the allocated and initialized chunk to the function caller function <strong>omalloc_make_chunks()</strong>, returns the new initialized and allocated chunk <strong>p</strong> to <strong>bp</strong> and after lineno. <strong>903</strong> it checks bp for NULL and if bp is not NULL then it assigns the new page that it creates on line no. <strong>895</strong>, that is, <code>bp-&gt;page = pp;</code>. Then, it invokes <code>insert(d, (void *)((uintptr_t)pp | (bits + 1)), (uintptr_t)bp, NULL)</code> and as we have previously understood that <code>insert()</code> is use to keep track of regions by keeping their address and size into a hash table.
Defination for <code>insert(struct dir_info *d, void *p, size_t sz, void *f)</code> as given below:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">564</span> <span style="color:#75715e">/*
</span><span style="color:#75715e">565  * The hashtable uses the assumption that p is never NULL. This holds since
</span><span style="color:#75715e">566  * non-MAP_FIXED mappings with hint 0 start at BRKSIZ.
</span><span style="color:#75715e">567  */</span>
<span style="color:#ae81ff">568</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span>
<span style="color:#ae81ff">569</span> insert(<span style="color:#66d9ef">struct</span> dir_info <span style="color:#f92672">*</span>d, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>p, size_t sz, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>f)
<span style="color:#ae81ff">570</span> {
<span style="color:#ae81ff">571</span>         size_t index;
<span style="color:#ae81ff">572</span>         size_t mask;
<span style="color:#ae81ff">573</span>         <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>q;
<span style="color:#ae81ff">574</span>
<span style="color:#ae81ff">575</span>         <span style="color:#a6e22e">if</span> (d<span style="color:#f92672">-&gt;</span>regions_free <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">&lt;</span> d<span style="color:#f92672">-&gt;</span>regions_total) {
<span style="color:#ae81ff">576</span>                 <span style="color:#66d9ef">if</span> (omalloc_grow(d))
<span style="color:#ae81ff">577</span>                         <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
<span style="color:#ae81ff">578</span>         }
<span style="color:#ae81ff">579</span>         mask <span style="color:#f92672">=</span> d<span style="color:#f92672">-&gt;</span>regions_total <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
<span style="color:#ae81ff">580</span>         index <span style="color:#f92672">=</span> hash(p) <span style="color:#f92672">&amp;</span> mask;
<span style="color:#ae81ff">581</span>         q <span style="color:#f92672">=</span> d<span style="color:#f92672">-&gt;</span>r[index].p;
<span style="color:#ae81ff">582</span>         <span style="color:#a6e22e">STATS_INC</span>(d<span style="color:#f92672">-&gt;</span>inserts);
<span style="color:#ae81ff">583</span>         <span style="color:#a6e22e">while</span> (q <span style="color:#f92672">!=</span> NULL) {
<span style="color:#ae81ff">584</span>                 index <span style="color:#f92672">=</span> (index <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">&amp;</span> mask;
<span style="color:#ae81ff">585</span>                 q <span style="color:#f92672">=</span> d<span style="color:#f92672">-&gt;</span>r[index].p;
<span style="color:#ae81ff">586</span>                 STATS_INC(d<span style="color:#f92672">-&gt;</span>insert_collisions);
<span style="color:#ae81ff">587</span>         }
<span style="color:#ae81ff">588</span>         d<span style="color:#f92672">-&gt;</span>r[index].p <span style="color:#f92672">=</span> p;
<span style="color:#ae81ff">589</span>         d<span style="color:#f92672">-&gt;</span>r[index].size <span style="color:#f92672">=</span> sz;
<span style="color:#ae81ff">590</span> <span style="color:#960050;background-color:#1e0010">#</span>ifdef MALLOC_STATS
<span style="color:#ae81ff">591</span>         d<span style="color:#f92672">-&gt;</span>r[index].f <span style="color:#f92672">=</span> f;
<span style="color:#ae81ff">592</span> <span style="color:#960050;background-color:#1e0010">#</span>endif
<span style="color:#ae81ff">593</span>         d<span style="color:#f92672">-&gt;</span>regions_free<span style="color:#f92672">--</span>;
<span style="color:#ae81ff">594</span>         <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
<span style="color:#ae81ff">595</span> }
</code></pre></div><ul>
<li>we can see that initially it checks for whether the slots is too filled, which means more than 75% (&gt;75%), if yes then it calls <code>omalloc_grow(d);</code> and returns 1, if no then means it is less 75% (&lt;75%) then it decrements <strong>d-&gt;regions_total</strong> by <strong>1</strong> and assign it to mask variable. Then it calculates, index, through anding (&amp;) a <strong>hash(p)</strong> function and <strong>mask</strong>. Defination of <strong>hash(p)</strong> function given below:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">254</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> size_t
<span style="color:#ae81ff">255</span> <span style="color:#a6e22e">hash</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>p)
<span style="color:#ae81ff">256</span> {
<span style="color:#ae81ff">257</span>         size_t sum;
<span style="color:#ae81ff">258</span>         uintptr_t u;
<span style="color:#ae81ff">259</span>
<span style="color:#ae81ff">260</span>         u <span style="color:#f92672">=</span> (uintptr_t)p <span style="color:#f92672">&gt;&gt;</span> MALLOC_PAGESHIFT;
<span style="color:#ae81ff">261</span>         sum <span style="color:#f92672">=</span> u;
<span style="color:#ae81ff">262</span>         sum <span style="color:#f92672">=</span> (sum <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">7</span>) <span style="color:#f92672">-</span> sum <span style="color:#f92672">+</span> (u <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">16</span>);
<span style="color:#ae81ff">263</span> <span style="color:#960050;background-color:#1e0010">#</span>ifdef __LP64__
<span style="color:#ae81ff">264</span>         sum <span style="color:#f92672">=</span> (sum <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">7</span>) <span style="color:#f92672">-</span> sum <span style="color:#f92672">+</span> (u <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">32</span>);
<span style="color:#ae81ff">265</span>         sum <span style="color:#f92672">=</span> (sum <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">7</span>) <span style="color:#f92672">-</span> sum <span style="color:#f92672">+</span> (u <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">48</span>);
<span style="color:#ae81ff">266</span> <span style="color:#960050;background-color:#1e0010">#</span>endif
<span style="color:#ae81ff">267</span>         <span style="color:#66d9ef">return</span> sum;
<span style="color:#ae81ff">268</span> }
</code></pre></div><ul>
<li><strong>hash(p)</strong> - after doing some shifting, it returns the sum. Coming back to <code>insert()</code>, <strong>d-&gt;r</strong> refers to the structure <strong>struct region_info</strong>, which has address and size to maintain mmap&rsquo;ed regions into hash table. After that it assigns the already existing address to q, that is, <strong>q = d-&gt;r[index].p</strong>. If q is not NULL then it again calulcates the index and then finds the q and increment the collisions information for stats. if q is NULL, then it simply keeps the new addr p to <strong>struct region_info</strong>, same for size, then it decrements the free slots count</li>
<li>then, coming back to <code>omalloc_make_chunks()</code>, it inserts list head using <strong>LIST_INSERT_HEAD(&amp;d-&gt;chunk_dir[bits][listnum], bp, entries);</strong>, where bits is 4 for our case and listnum is random for each invocaton then returns the associated meta-info, <strong>bp</strong> with the allocated-initialized chunk information and page of chunks, <strong>bp-&gt;page</strong></li>
<li>as per my understanding, from the <strong>malloc_bytes</strong> the <strong>bp</strong> seems to be the allocated chunks in a page, and <strong>pp</strong> seems to be the bucket of chunks or can say a page of chunks as we can see from the <code>omalloc_make_chunks():L895</code></li>
<li>now, coming back to the <strong>malloc_bytes()</strong>, it checks for chunk canary corruption on line no. 976, <code>if(bp-&gt;canary != (u_short)d-&gt;canary1)</code>, if the condition is true then calls wrterror() with the string <code>&quot;chunk info corrupted&quot;</code> and then calls abort()</li>
<li>if the condition is false then it calculates <strong>i</strong>, <code>i = (r / MALLOC_CHUNK_LISTS) &amp; (bp-&gt;total - 1);</code>, where r is the random byte, <strong>MALLOC_CHUNK_LISTS</strong> is 4 and <strong>bp-&gt;total</strong> is the total no. of chunks. Then, after calculating the i it calculates the index of the chunk which is free, as if we remember <strong>bp-&gt;bits</strong> is responsible for tracking the free chunks to use.<br>
<br>
Found one of the interesting <a href="http://www.ouah.org/BSD-heap-smashing.txt">old paper</a> which provides some details about the <strong>phkmalloc</strong> internals. According to the paper, it is mentioned that</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">struct pginfo {
    struct pginfo       *next;  /* next on the free list */
    void                *page;  /* Pointer to the page */
    u_short             size;   /* size of this page&#39;s chunks */
    u_short             shift;  /* How far to shift for this size chunks */
    u_short             free;   /* How many free chunks */
    u_short             total;  /* How many chunk */
    u_int               bits[1]; /* Which chunks are free */
};

- where the next field is a pointer to the next structure in the list, or 0 if the
element is the last of the list.
- The page field points to the beginning of the page (it is always a multiple of
malloc_pagesize).
- The size field is set to the size in bytes of the chunks contained in this page.
- The free field is the number of free chunks in the page.
- The total field is the sum of the number of free chunks in the page and of the
number of allocated chunks in the page. The page is freed (ie. returned to the
lower layer) whenever ( free == total ) becomes true.
- **the bits field is a variable size array indicating which chunks in the
page are free chunks. Each chunk is associated with a unique bit in the field,
namely the bit obtained when applying the ( 1 &lt;&lt; n ) mask to bits[i]** where:

  ( i * MALLOC_BITS ) + n = ( chunk_address &amp; malloc_pagemask ) / chunk_size

MALLOC_BITS is the number of bits a u_int has on the specific architecture where phkmalloc is using. It is defined as follows:

#define MALLOC_BITS     ((int)(8*sizeof(u_int)))

This bit is set to one when the chunk is free, and to 0 when the chunk is in
use. Of course, the effective size of the bits field will depend on the number
of chunks in the page.
</code></pre></div><ul>
<li>the calculation given below computes the offset of the chunk in the page</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">...
...
...
<span style="color:#ae81ff">981</span>		<span style="color:#75715e">/* start somewhere in a short */</span>
<span style="color:#ae81ff">982</span>		lp <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>bp<span style="color:#f92672">-&gt;</span>bits[i <span style="color:#f92672">/</span> MALLOC_BITS];
<span style="color:#ae81ff">983</span>		<span style="color:#a6e22e">if</span> (<span style="color:#f92672">*</span>lp) {
<span style="color:#ae81ff">984</span>			j <span style="color:#f92672">=</span> i <span style="color:#f92672">%</span> MALLOC_BITS;
<span style="color:#ae81ff">985</span>			k <span style="color:#f92672">=</span> ffs(<span style="color:#f92672">*</span>lp <span style="color:#f92672">&gt;&gt;</span> j);
<span style="color:#ae81ff">986</span>			<span style="color:#66d9ef">if</span> (k <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
<span style="color:#ae81ff">987</span>				k <span style="color:#f92672">+=</span> j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
<span style="color:#ae81ff">988</span>				<span style="color:#66d9ef">goto</span> found;
<span style="color:#ae81ff">989</span>			}
<span style="color:#ae81ff">990</span>		}
<span style="color:#ae81ff">991</span>		<span style="color:#75715e">/* no bit halfway, go to next full short */</span>
<span style="color:#ae81ff">992</span>		i <span style="color:#f92672">/=</span> MALLOC_BITS;
<span style="color:#ae81ff">993</span>		<span style="color:#66d9ef">for</span> (;;) {
<span style="color:#ae81ff">994</span>			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">++</span>i <span style="color:#f92672">&gt;=</span> bp<span style="color:#f92672">-&gt;</span>total <span style="color:#f92672">/</span> MALLOC_BITS)
<span style="color:#ae81ff">995</span>				i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#ae81ff">996</span>			lp <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>bp<span style="color:#f92672">-&gt;</span>bits[i];
<span style="color:#ae81ff">997</span>			<span style="color:#a6e22e">if</span> (<span style="color:#f92672">*</span>lp) {
<span style="color:#ae81ff">998</span>				k <span style="color:#f92672">=</span> ffs(<span style="color:#f92672">*</span>lp) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
<span style="color:#ae81ff">999</span>				<span style="color:#66d9ef">break</span>;
<span style="color:#ae81ff">1000</span>			}
<span style="color:#ae81ff">1001</span>		}
<span style="color:#ae81ff">1002</span>	found:
<span style="color:#ae81ff">1003</span>	<span style="color:#960050;background-color:#1e0010">#</span>ifdef MALLOC_STATS
<span style="color:#ae81ff">1004</span>		<span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> k <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
<span style="color:#ae81ff">1005</span>			<span style="color:#66d9ef">struct</span> region_info <span style="color:#f92672">*</span>r <span style="color:#f92672">=</span> find(d, bp<span style="color:#f92672">-&gt;</span>page);
<span style="color:#ae81ff">1006</span>			r<span style="color:#f92672">-&gt;</span>f <span style="color:#f92672">=</span> f;
<span style="color:#ae81ff">1007</span>		}
<span style="color:#ae81ff">1008</span>	<span style="color:#960050;background-color:#1e0010">#</span>endif
<span style="color:#ae81ff">1009</span>	
<span style="color:#ae81ff">1010</span>		<span style="color:#f92672">*</span>lp <span style="color:#f92672">^=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> k;
<span style="color:#ae81ff">1011</span>	
<span style="color:#ae81ff">1012</span>		<span style="color:#75715e">/* If there are no more free, remove from free-list */</span>
<span style="color:#ae81ff">1013</span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">--</span>bp<span style="color:#f92672">-&gt;</span>free <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
<span style="color:#ae81ff">1014</span>			LIST_REMOVE(bp, entries);
<span style="color:#ae81ff">1015</span>	
<span style="color:#ae81ff">1016</span>		<span style="color:#75715e">/* Adjust to the real offset of that chunk */</span>
<span style="color:#ae81ff">1017</span>		k <span style="color:#f92672">+=</span> (lp <span style="color:#f92672">-</span> bp<span style="color:#f92672">-&gt;</span>bits) <span style="color:#f92672">*</span> MALLOC_BITS;
<span style="color:#ae81ff">1018</span>	
<span style="color:#ae81ff">1019</span>		<span style="color:#a6e22e">if</span> (mopts.chunk_canaries <span style="color:#f92672">&amp;&amp;</span> size <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
<span style="color:#ae81ff">1020</span>			bp<span style="color:#f92672">-&gt;</span>bits[bp<span style="color:#f92672">-&gt;</span>offset <span style="color:#f92672">+</span> k] <span style="color:#f92672">=</span> size;
<span style="color:#ae81ff">1021</span>	
<span style="color:#ae81ff">1022</span>		k <span style="color:#f92672">&lt;&lt;=</span> bp<span style="color:#f92672">-&gt;</span>shift;
<span style="color:#ae81ff">1023</span>	
<span style="color:#ae81ff">1024</span>		p <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)bp<span style="color:#f92672">-&gt;</span>page <span style="color:#f92672">+</span> k;
<span style="color:#ae81ff">1025</span>		<span style="color:#a6e22e">if</span> (bp<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
<span style="color:#ae81ff">1026</span>			<span style="color:#66d9ef">if</span> (d<span style="color:#f92672">-&gt;</span>malloc_junk <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>)
<span style="color:#ae81ff">1027</span>				memset(p, SOME_JUNK, bp<span style="color:#f92672">-&gt;</span>size);
<span style="color:#ae81ff">1028</span>			<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (mopts.chunk_canaries)
<span style="color:#ae81ff">1029</span>				fill_canary(p, size, bp<span style="color:#f92672">-&gt;</span>size);
<span style="color:#ae81ff">1030</span>		}
<span style="color:#ae81ff">1031</span>		<span style="color:#66d9ef">return</span> p;
<span style="color:#ae81ff">1032</span>	}
</code></pre></div><ul>
<li>It assigns the address of <strong>bp-&gt;bits[13]</strong> to <strong>lp</strong>, for our case i = 0xd3 (or 211) and MALLOC_BITS is 16 then if *<strong>lp</strong> is not null then it assigns <strong>i % MALLOC_BITS</strong> to j, which is j = 3, then it goes to find the first set bit and assign it to k, <code>k = ffs(*lp &gt;&gt; j);</code>, <code>ffs()</code> defination as given below</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"> <span style="color:#ae81ff">1</span> <span style="color:#75715e">/* ffs -- Find the first bit set in the parameter
</span><span style="color:#75715e"> 2
</span><span style="color:#75715e"> 3 @deftypefn Supplemental int ffs (int @var{valu})
</span><span style="color:#75715e"> 4
</span><span style="color:#75715e"> 5 Find the first (least significant) bit set in @var{valu}.  Bits are
</span><span style="color:#75715e"> 6 numbered from right to left, starting with bit 1 (corresponding to the
</span><span style="color:#75715e"> 7 value 1).  If @var{valu} is zero, zero is returned.
</span><span style="color:#75715e"> 8
</span><span style="color:#75715e"> 9 @end deftypefn
</span><span style="color:#75715e">10
</span><span style="color:#75715e">11 */</span>
<span style="color:#ae81ff">12</span>
<span style="color:#ae81ff">13</span> <span style="color:#66d9ef">int</span>
<span style="color:#ae81ff">14</span> ffs (<span style="color:#66d9ef">register</span> <span style="color:#66d9ef">int</span> valu)
<span style="color:#ae81ff">15</span> {
<span style="color:#ae81ff">16</span>   <span style="color:#66d9ef">register</span> <span style="color:#66d9ef">int</span> bit;
<span style="color:#ae81ff">17</span>
<span style="color:#ae81ff">18</span>   <span style="color:#a6e22e">if</span> (valu <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
<span style="color:#ae81ff">19</span>     <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
<span style="color:#ae81ff">20</span>
<span style="color:#ae81ff">21</span>   <span style="color:#66d9ef">for</span> (bit <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">!</span>(valu <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>); bit<span style="color:#f92672">++</span>)
<span style="color:#ae81ff">22</span>         valu <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#ae81ff">23</span>
<span style="color:#ae81ff">24</span>   <span style="color:#66d9ef">return</span> bit;
<span style="color:#ae81ff">25</span> }
</code></pre></div><ul>
<li>For our case,
<ul>
<li>*lp is 0xffff and j is 3, so the outcome of operation *<strong>lp &raquo; j</strong> is 8191 and ffs(8191) is 1 which returns to k and if k != 0 then k = k + j - 1 =&gt; k = 1 + 3 - 1 =&gt; k = 3, then goto found</li>
</ul>
</li>
<li><code>lp = *lp ^ 1 &lt;&lt; k</code>, then 0xffff ^ 1 &laquo; 0x3 =&gt; *lp = 0xfff7. Here, it sets the bits of the bitmap. Then, if bp-&gt;free is 0 then remove lists bp and decrement the bp-&gt;free value, if not 0 then also decrement the bp-&gt;free and k = k + (lp - bp-&gt;bits) * MALLOC_BITS; =&gt; k = 0xd3 (or 211). Then, check if mopts.chunk_canaries is enable and size &gt; 0, if yes, then bp-&gt;bits[bp-&gt;offset + k] = size =&gt; bp-&gt;bits[16 + 211] = 0x8</li>
<li>Then, <strong>k &laquo;= bp-&gt;shift</strong> which means <strong>k = k &laquo; bp-&gt;shift</strong> =&gt; k = 0xd3 (or 211) * 16 =&gt; k = 0xd30 (or 3376). Then, calculate offset in the page, <code>p = (char *)bp-&gt;page + k;</code>, for our case, bp-&gt;page is 0xcde2d918000 and k is 0xd30 =&gt; p = 0xcde2d918d30. Then it checks if the bp-&gt;size &gt; 0, if true then check for more junking through, <strong>d-&gt;malloc_junk == 2</strong>, if more junking set, then it copies SOME_JUNK to p till the bp-&gt;size, but if no more_junking option set then it checks for mopt.chunk_canaries, and if canary is enable then, fill_canary functions calls with p, size and bp-&gt;size</li>
<li>Here, in short, information about the offset calculations</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">- bp-&gt;page or pp is the page of chunks and bp is the associated meta-info
- k is the chunk number, before shiting, which means k is the index for the chunk in the page bp-&gt;page
- After shifting, k becomes the byte offset of the chunk inside the bp-&gt;page page
</code></pre></div><ul>
<li><code>fill_canary()</code> function as given below</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">938</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>
<span style="color:#ae81ff">939</span> <span style="color:#a6e22e">fill_canary</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>ptr, size_t sz, size_t allocated)
<span style="color:#ae81ff">940</span> {
<span style="color:#ae81ff">941</span>         size_t check_sz <span style="color:#f92672">=</span> allocated <span style="color:#f92672">-</span> sz;
<span style="color:#ae81ff">942</span>
<span style="color:#ae81ff">943</span>         <span style="color:#66d9ef">if</span> (check_sz <span style="color:#f92672">&gt;</span> CHUNK_CHECK_LENGTH)
<span style="color:#ae81ff">944</span>                 check_sz <span style="color:#f92672">=</span> CHUNK_CHECK_LENGTH;
<span style="color:#ae81ff">945</span>         memset(ptr <span style="color:#f92672">+</span> sz, SOME_JUNK, check_sz);
<span style="color:#ae81ff">946</span> }
</code></pre></div><ul>
<li>For our case, check_sz is <strong>16 - 8</strong>, which further resolves down to check_sz = 8, then check for maximum chunk length and if greater than CHUNK_CHECK_LENGTH then sets the CHUNK_CHECK_LENGTH to check_sz and then copy the SOME_JUNK to <strong>ptr + sz</strong> till size <strong>check_sz</strong> and further ptr + sz becomes 0xcde2d918d38, where ptr=0xcde2d918d30 and sz=0x8 copies SOME_JUNK till check_sz which has 0x10 length. Now, if in the case of heap-overflow, if any buffer tries to write more than size sz, that is, 0x8 then it corrupts the SOME_JUNK value and that detects as heap-overflow attack and abort(). Rest about canary validation we will see on further series on malloc family calls</li>
<li>Then, finally it returns the page + offset address filled with canary</li>
<li>Now, the <strong>malloc_bytes()</strong> is completed and as we can see further in <strong>omalloc()</strong> defination, after the <strong>malloc_bytes()</strong> function call, it checks for zero_filling and also checks if p != NULL and sz &gt; 0 and if all conditions meets then it copies zero to entire address <strong>p</strong> till size sz and returns <strong>p</strong></li>
<li>coming back to <code>malloc(size_t size)</code>, after completing the <code>omalloc()</code> function, it expands <strong>EPILOGUE()</strong> code.<br>
Following the code explains about the EPILOGUE() macro</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">1269</span> <span style="color:#960050;background-color:#1e0010">#</span>define EPILOGUE()                              \
<span style="color:#ae81ff">1270</span>         d<span style="color:#f92672">-&gt;</span>active<span style="color:#f92672">--</span>;                            \
<span style="color:#ae81ff">1271</span>         <span style="color:#a6e22e">_MALLOC_UNLOCK</span>(d<span style="color:#f92672">-&gt;</span>mutex);               \
<span style="color:#ae81ff">1272</span>         <span style="color:#a6e22e">if</span> (r <span style="color:#f92672">==</span> NULL <span style="color:#f92672">&amp;&amp;</span> mopts.malloc_xmalloc)  \
<span style="color:#ae81ff">1273</span>                 wrterror(d, <span style="color:#e6db74">&#34;out of memory&#34;</span>);   \
<span style="color:#ae81ff">1274</span>         <span style="color:#a6e22e">if</span> (r <span style="color:#f92672">!=</span> NULL)                          \
<span style="color:#ae81ff">1275</span>                 errno <span style="color:#f92672">=</span> saved_errno;            \
</code></pre></div><ul>
<li>above code shows what EPILOGUE() does
<ul>
<li>It decrements the active count</li>
<li>Unlock the locked stuff</li>
<li>Then, it checks if <strong>r</strong> is NULL and also checks for <strong>mopts.malloc_xmalloc</strong> then it &ldquo;prints out of memory&rdquo; as error and abort() but if <strong>r</strong> is not NULL then it saves <strong>saved_errno</strong> to <strong>errno</strong> variable and completes the epilogue() process</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">1277</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>
<span style="color:#ae81ff">1278</span> <span style="color:#a6e22e">malloc</span>(size_t size)
<span style="color:#ae81ff">1279</span> {
<span style="color:#ae81ff">1280</span>         <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>r;
<span style="color:#ae81ff">1281</span>         <span style="color:#66d9ef">struct</span> dir_info <span style="color:#f92672">*</span>d;
<span style="color:#ae81ff">1282</span>         <span style="color:#66d9ef">int</span> saved_errno <span style="color:#f92672">=</span> errno;
<span style="color:#ae81ff">1283</span>
<span style="color:#ae81ff">1284</span>         PROLOGUE(getpool(), <span style="color:#e6db74">&#34;malloc&#34;</span>)
<span style="color:#ae81ff">1285</span>         r <span style="color:#f92672">=</span> omalloc(d, size, <span style="color:#ae81ff">0</span>, CALLER);
<span style="color:#ae81ff">1286</span>         EPILOGUE()
<span style="color:#ae81ff">1287</span>         <span style="color:#66d9ef">return</span> r;
<span style="color:#ae81ff">1288</span> }
</code></pre></div><ul>
<li>after EPILOGUE(), it returns the <strong>r</strong>, which has the address value, <code>0xcde2d918d30</code>, from the <code>malloc_bytes():L1024</code> - <code>(char *)bp-&gt;page + k</code></li>
<li>coming back to our sample code we have <code>buff1 = (char *)malloc(8);</code> and after that it copies the user controlled input to buff1 through vulnerable string function, strcpy() and then calls <code>free(buff1)</code>.<br>
<br>
Sample code showing the canary overwrite and detection:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">openbsd# LD_PRELOAD<span style="color:#f92672">=</span>/usr/src/lib/libc/obj/libc.so.95.1 gdb -q sample
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> br main
Breakpoint <span style="color:#ae81ff">1</span> at 0x1363: file sample.c, line 7.
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> r AAAABBBBCCCCDDDD
Starting program: /root/test/sample AAAABBBBCCCCDDDD
Breakpoint <span style="color:#ae81ff">1</span> at 0x4517aff7363: file sample.c, line 7.
Error <span style="color:#66d9ef">while</span> reading shared library symbols:
Dwarf Error: wrong version in compilation unit header <span style="color:#f92672">(</span>is 4, should be 2<span style="color:#f92672">)</span> <span style="color:#f92672">[</span>in module /usr/libexec/ld.so<span style="color:#f92672">]</span>

Breakpoint 1, main <span style="color:#f92672">(</span>argc<span style="color:#f92672">=</span>2, argv<span style="color:#f92672">=</span>0x7f7ffffee678<span style="color:#f92672">)</span> at sample.c:7
7		char *buff1 <span style="color:#f92672">=</span> NULL;
Current language:  auto; currently minimal
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> n
8		buff1 <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>char *<span style="color:#f92672">)</span>malloc<span style="color:#f92672">(</span>8<span style="color:#f92672">)</span>;
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> n
9		strcpy<span style="color:#f92672">(</span>buff1, argv<span style="color:#f92672">[</span>1<span style="color:#f92672">])</span>;
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> x/16x buff1
0x453ec9b6fe0:	0x00000000	0x00000000	0xdbdbdbdb	0xdbdbdbdb
0x453ec9b6ff0:	0x00000000	0x00000000	0x00000000	0x00000000
0x453ec9b7000:	Cannot access memory at address 0x453ec9b7000
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> n
10		free<span style="color:#f92672">(</span>buff1<span style="color:#f92672">)</span>;
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> x/16x buff1
0x453ec9b6fe0:	0x41414141	0x42424242	0x43434343	0x44444444
0x453ec9b6ff0:	0x00000000	0x00000000	0x00000000	0x00000000
0x453ec9b7000:	Cannot access memory at address 0x453ec9b7000
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> c
Continuing.
sample<span style="color:#f92672">(</span>3165<span style="color:#f92672">)</span> in free<span style="color:#f92672">()</span>: chunk canary corrupted 0x453ec9b6fe0 0x8@0x8

Program received signal SIGABRT, Aborted.
thrkill <span style="color:#f92672">()</span> at -:3
3	-: No such file or directory.
	in -
Current language:  auto; currently asm
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span>
</code></pre></div><ul>
<li>From the above debugging, we can see that just after the malloc(3) allocation there are canaries with <strong>0xdb</strong> bytes, which is filled by the <code>fill_canary()</code> which we have already seen and understood.</li>
<li>Then, after the memory allocation that is explained above, it copies the user controlled input to that memory area and after giving string <strong>AAAABBBBCCCCDDDD</strong>, we can see that the canaries are corrupted as it has overwritten the <strong>0xdb</strong> bytes with the <strong>0x43</strong> and <strong>0x44</strong> which is <strong>C</strong> and <strong>D</strong> then next it calls <strong>free(buff1)</strong>, which is responsible to validate canaries and calls abort() if corrupted with the information like chunk address and size.</li>
<li>So, validation of canaries in user-related chunk is validated in <strong>free()</strong> which we will cover in the further series of malloc(3) friends library calls</li>
</ul>
<h3 id="references">References:<a href="#references" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<ul>
<li><a href="https://man.openbsd.org/malloc.3">malloc(3)</a> man page</li>
<li><a href="https://marc.info/?l=openbsd-tech&amp;m=158378974915381&amp;w=2">OpenBSD community - mailing list</a></li>
<li><a href="https://www.openbsd.com.au/papers/eurobsdcon2009/otto-malloc.pdf">A new malloc(3) for OpenBSD</a> slides by <a href="https://twitter.com/ottom6k/"><strong><em>Otto Moerbeek</em></strong></a></li>
<li><a href="http://www.ouah.org/BSD-heap-smashing.txt">BSD Heap Smashing</a>, paper by <strong><em>bbp@krukh.net</em></strong> on <strong><em>phkmalloc</em></strong> <!-- raw HTML omitted -->[from security point of view]<!-- raw HTML omitted --></li>
<li><a href="https://github.com/libressl-portable/openbsd/commits/master/src/lib/libc/stdlib/malloc.c">GitHub code history for old commit messages</a></li>
<li><a href="https://marc.info/?l=openbsd-tech&amp;w=2&amp;r=1&amp;s=malloc&amp;q=b">information on all the commits in mailing list</a></li>
<li><a href="http://phk.freebsd.dk/pubs/malloc.pdf">phkmalloc</a>, paper by <strong><em>Poul-Henning Kamp</em></strong></li>
<li><a href="https://github.com/mulander/openbsd-daily">malloc(3) code series</a> by <a href="https://twitter.com/mulander"><strong><em>Adam Wolk</em></strong></a> and <strong><em>@DuClare</em></strong></li>
<li>Discussions on twitter with developers</li>
<li>Google :)</li>
</ul>
<p>Finally!! It was a bit long journey. If something is missing or not correct, please feel free to update.</p>
<p><strong>Again, a huge thanks to all OpenBSD community and especially <a href="https://twitter.com/ottom6k/"><strong><em>Otto@</em></strong></a> for helping me to understand the malloc internals and patiently listening my queries :).</strong>
<br>
<br>
<code>Happy Kernel Hacking</code></p>

      </div></div>

  
  
<div class="pagination">
    <div class="pagination__title">
        <span class="pagination__title-h">Read other posts</span>
        <hr />
    </div>
    <div class="pagination__buttons">
        
        
        <span class="button next">
            <a href="https://bsdb0y.github.io/posts/openbsd-kernel-internals-creation-of-process-from-user-space-to-kernel-space/">
                <span class="button__text">OpenBSD Kernel Internals  Creation of process from user-space to kernel space</span>
                <span class="button__icon"></span>
            </a>
        </span>
        
    </div>
</div>

  

  

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>Neeraj Pal</span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
</footer>

<script src="https://bsdb0y.github.io/assets/main.js"></script>
<script src="https://bsdb0y.github.io/assets/prism.js"></script>







  
</div>

</body>
</html>
